args = commandArgs(trailingOnly=TRUE)
# General Description ############# 

# Main functionallity: Aggregation / analysis of data generated by "AXEL_edit_Ores2b2_cluster_universal_faster_2.R" 

# Inputs :
#
#  - AXEL_edit_Ores2b2_cluster_universal_faster_2.R : all_species.txt, all_gran_table_com.txt, agg*.txt, HH*.txt
#
#

# Load libraries ###################

library(Rfast)
library(plyr)
library(zoo)
library(survival)
library(maxLik)
library(plyr)
library(ggplot2)
library(deSolve)
library(ggplot2)

# Functions ###################

do_others<-0

aicc.loess <- function(fit) {
  # compute AIC_C for a LOESS fit, from:
  #
  # Hurvich, C.M., Simonoff, J.S., and Tsai, C. L. 1998. Smoothing
  # parameter selection in nonparametric regression using an improved
  # Akaike Information Criterion. Journal of the Royal Statistical
  # Society B 60: 271â€“293.
  #
  # @param fit loess fit
  # @return 'aicc' value
  stopifnot(inherits(fit, 'loess'))
  # parameters
  n <- fit$n
  trace <- fit$trace.hat
  sigma2 <- sum(resid(fit) ^ 2) / (n - 1)
  return(log(sigma2) + 1 + 2 * (2 * (trace + 1)) / (n - trace - 2))
}

autoloess <- function(fit, span=c(.1, .9)) {
  # compute loess fit which has span minimizes AIC_C
  #
  # @param fit loess fit; span parameter value doesn't matter
  # @param span a two-value vector representing the minimum and
  # maximum span values
  # @return loess fit with span minimizing the AIC_C function
  stopifnot(inherits(fit, 'loess'), length(span) == 2)
  # loss function in form to be used by optimize
  f <- function(span) aicc.loess(update(fit, span=span))
  # find best loess according to loss function
  o <- optimize(f, span)
  print(o$minimum)
  return(update(fit, span=o$minimum))
}

cubic<-function(x,a,b,c,d){a+b*x+c*x^2+d*x^3}

{
  
  findFitConsumer_tt <- function(agg){
    repeat{
      H <- agg*exp(rnorm(Sr,sd=sigma))*K*epsilon/resp
      if(sum(H)>1) break
    }
    return(list(H=H,agg=agg))
  }
  
  serial_extinction_t<-function(Hi){
    # Simulates the serial extinction process at equilibrium
    repeat{
      sum_Hi <- sum(Hi)
      sum_H2i <- sum(Hi^2)
      max_Hi <- max(Hi)
      out<-Hi
      if(sum_H2i >=  max_Hi*(sum_Hi-1)) break
      deadd<-which.max(Hi)
      Hi <- Hi[-deadd]
    }
    return(out)
  }
  
  find_mu_sd<-function(s_r,sigmaa){
    #Function for estimating the expected value of the strongest link strength, i.e. E(max(exp(sigmaa*xi_{max,i})))
    
    n_samples<-1000#Number of samples
    sum_m<-rep(0,n_samples)
    for (i in 1:n_samples){
      sum_m[i]<-sum(exp(sigmaa*rnorm(s_r,0,1)))
    }
    mean_sum_m<-mean(log(sum_m))
    sd_sum_m<-(var(log(sum_m)))^0.5
    out<-list(mean_sum_m,sd_sum_m)
    return(out)
  }
  
  ## Is the invader outcompeted?
  
  parColMax <- function(M){
    colMaxs(M,value=T,parallel=T)
  }
  parColWhichMax <- function(M){
    colMaxs(M,value=F)
  }
  parColWhichMins <- function(M){
    colMins(M,value=F)
  }
  
  pickRows <- function(M,indices){
    M[matrix(c(indices,seq(length(indices))),ncol=2)]
  }
  parColSums <- function(M){
    colsums(M,parallel=T)
  }
  
  ## Is the invader outcompeted?
  outcompeted <- function(H,t_H_HH,HHSums,HH2Sums){
    directly <-
      any( (HHSums-1) * t_H_HH >
             (sum(H)-1) * HH2Sums )
    if(directly) return(T)
    return(directly) #directly |
  }
  
  ## Does the invader outcompete residents?
  ## [ equivalent to apply(X = HH, MARGIN = 2, FUN = outcompeted,matrix(H,ncol=1)) ]
  outcompetes_directly <- function(H,t_H_HH,HHSums){
    directly <- (sum(H)-1) * t_H_HH > (HHSums-1) * sum(H^2)
    return(directly)
  }
  
  ## Which resident (output row) outcompetes which other resident (output column)?
  ## [ equivalent to t(apply(X = HH, MARGIN = 2, FUN = outcompetes, HH)),
  ## except for diagonal]
  outcompetition <- function(HH){
    colSumsHHm1 <- parColSums(HH)-1
    
    # directly <-
    #   colSumsHHm1 * mat.mult(t(HH), HH) >
    #   outer(  parColSums(HH^2), colSumsHHm1  )
    # diag(directly) <- FALSE #should always be FALSE, apparently some numerical issues
    
    mainResource <- parColWhichMax(HH)
    indirectly <- t( HH[mainResource,] > pickRows(HH,mainResource) )
    return(  indirectly ) #directly |
  }
  
  outcompetition_directly <- function(HH,sum_HH,sum_HH2){
    colSumsHHm1 <- sum_HH-1
    directly <-
      colSumsHHm1 * mat.mult(t(HH), HH) >
      outer(  sum_HH2, colSumsHHm1  )
    diag(directly) <- FALSE #should always be FALSE, apparently some numerical issues
    return( directly)
  }
  
  findFitConsumer <- function(aggs){
    repeat{
      parent<-sample(aggs,1)
      agg <- a1*a2^rnorm(1)*parent
      H <- agg*exp(rnorm(Sr,sd=sigma))*constanttt
      if(sum(H)>1) break
    }
    return(list(H=H,agg=agg,parent_number=which(aggs==parent)))
  }
  
  ## One step in serial extinction for one consumer
  resourceEx1 <- function(H){
    if((sum(H)-1)*max(H) > sum(H^2)){
      return(which.max(H));
    }else{
      return(0);
    }
  }
  
  ## One step in serial extinction for many consumers
  resourceEx <- function(HH){
    ex <-
      (parColSums(HH)-1)*parColMax(HH) > parColSums(HH^2)
    if(any(ex)){
      return(list(apply(HH[,ex,drop=F],MARGIN = 2,which.max),ex));
    }else{
      return(list(0,ex));
    }
  }
  
  check_extinction<-function(HH){
    A<-resp*HH/(K*epsilon)
    C_P<-diag(rep(K,dim(HH)[1]))
    C_hat<-epsilon*(t(A)%*%chol2inv(C_P)%*%A)
    s<-matrix(rep(growth,dim(HH)[1]),nrow=dim(HH)[1])
    s_hat<-epsilon*t(A)%*%chol2inv(C_P)%*%s-matrix(rep(resp,dim(HH)[2]),nrow=dim(HH)[2])
    b_C<-chol2inv(C_hat)%*%s_hat
    b_R<-(s-A%*%b_C)/K
    return(b_R)
  }
  
  predict_prob<-function(beta0,beta1,beta2,beta3,x){#predict probability from parameter estimates
    p<-cubic(x,beta0,beta1,beta2,beta3)
    return(p)
  }
  
  invasion_prob_c<-function(l_a_m,mu,sd){
    pass<-(log(resp/(epsilon*exp(l_a_m)*K*P_b_m))-as.numeric(mu))/(as.numeric(sd))
    return(1-pnorm(pass,0,1))
  }
  
  invasion_prob<-function(l_a_m,mu,sd){
    pass<-(log(resp/(epsilon*exp(l_a_m)*K))-as.numeric(mu))/(as.numeric(sd))
    return(1-pnorm(pass,0,1))
  }
  
  #Probability of yielding mutant given resident
  mut_prob_given_ar<-function(l_a_m,l_a_r){
    mu_a<-m_a+l_a_r
    # return(exp(-((l_a_m-mu_a)^2)/(2*(s_a^2)))/((2*pi*(s_a^2))^0.5))
    return(dnorm(l_a_m,mu_a,s_a))
  }
  # dnorm(-5,m_a-5,1.14)
  # mut_prob_given_ar(-5,-5)
  
  #Joint probability of yielding mutant (given resident) and that the mutant succesfuly invades
  joint_prob<-function(l_a_mm,l_a_rr,mu,sd){
    return(mut_prob_given_ar(l_a_mm,l_a_rr)*invasion_prob(l_a_mm,mu,sd))
  }
  
  joint_prob_c<-function(l_a_mm,l_a_rr,mu,sd){
    return(mut_prob_given_ar(l_a_mm,l_a_rr)*invasion_prob_c(l_a_mm,mu,sd))
  }
  
  #Birth probability: intergrate joint probability over all possible mutants.
  birth_prob<-function(l_a_rr,mu,sd){
    return(invasion_prob(l_a_rr+m_a,mu,sd))
    # return(integrate(joint_prob,lower=-Inf,upper=Inf,l_a_rr=l_a_rr,mu=mu,sd=sd)$value)
  }
  
  birth_prob_c<-function(l_a_rr,mu,sd){
    return(invasion_prob_c(l_a_rr+m_a,mu,sd))
    # return(integrate(joint_prob_c,lower=-10,upper=10,l_a_rr=l_a_rr,mu=mu,sd=sd)$value)
  }
  #loop of webs
  findFitConsumer_without <- function(aggs,HH){
    Sr<-dim(HH)[1]
    repeat{
      parent<-sample(aggs,1)
      agg <- a1*a2^rnorm(1)*parent
      H <- agg*exp(rnorm(Sr,sd=sigma))*constanttt
      if(sum(H)>1) break
    }
    return(parent)
  }
  
  findFitConsumer_with <- function(aggs,HH){
    Sr<-dim(HH)[1];par_col_sum_yo<-parColSums(HH)
    par_col_sum_yo2<-parColSums(HH^2)
    repeat{
      parent<-sample(aggs,1)
      agg <- a1*a2^rnorm(1)*parent
      H <- agg*exp(rnorm(Sr,sd=sigma))*constanttt
      t_inv_HH<-t(H)%*%HH
      if(sum(H)>1 & !outcompeted(H,t_inv_HH, par_col_sum_yo, par_col_sum_yo2 )) break
    }
    return(parent)
  }
}

# Specific Commands #####################
# General Parameters ###################

sigma<-as.numeric(args[1])
a1<-(0.8^0.5)*as.numeric(args[2])
a2 <- (1.3^0.5)*1
resp<-0.1;
epsilon<-0.1;
K<-1
bin<-1000
m_a<-log(a1)
s_a<-a2
sigmaa<-4
bww<-1

# Data Loading and Aggregation ###########

load("Data/Pre_processed/95_optimised_K.RData")
# load("optimised_mu_sd_2.RData") # Loads the optimised value of mu_sd_2 generated using optimised_invasion_prob.R
# load("all_data_deconstructed_test.RData")

##-Load .txt fils from many simulations
All_species<-data.frame()
for (jjjj in list.files(pattern="all_species",recursive = T,full.names = T, path = path = "/Data/Raw/Deconstructed_assembly_model")){

all_species<-read.csv(jjjj)
all_species<-all_species[which(all_species$id!="id"),]
all_species<-all_species[which(all_species$id!=0),]
all_species[]<-lapply(all_species,function(x)as.numeric(as.character(x)))
all_species<-all_species[order(all_species$id),]
all_species_keep<-all_species[which(!all_species$outi<0),]
all_species_keep$lifetime<-all_species_keep$outi-all_species_keep$id
# # all_species_keep<-all_species_keep[which(all_species_keep$id<600000),]
# all_species_keep$fitness<-unlist(llply(all_species_keep$id,
#                                                   # Calculates how many mutants were generated
#                                                   function(x) length(which(all_species_keep$parent_id==x))))
All_species<-rbind(All_species,all_species_keep)

# pdf(paste(jjjj,".pdf",sep=""))
#   with(all_species_keep,plot(id,n_P,type="l",col="green",xlab="Time-steps",ylab="Species Richness"))
#   with(all_species_keep,lines(id,n_C,type="l",col="red",ylim=c(0,max(n_P))))
# dev.off()
}
bin<-1000
burn_in<-0.3
all_species_keep<-All_species
#-Load data relating to exploitative compeition compartments
all_gran_table_com<-read.table("all_gran_table_com.txt")

burn<-round(max(all_species_keep$id)*burn_in)
species_fitness_equilibrium<- all_species_keep[which(all_species_keep$id<=burn),]
# burn_out<-0.1
# burn<-round(max(all_species_keep$id)*burn_in)
# species_fitness_equilibrium<- species_fitness_equilibrium[which(species_fitness_equilibrium$id<=30000),]
species_fitness_equilibrium<-species_fitness_equilibrium[,-1]
species_fitness_equilibrium<-na.omit(species_fitness_equilibrium)
species_fitness_equilibrium$l_agg<-log(species_fitness_equilibrium$agg)
if(sum(species_fitness_equilibrium$lifetime[which(species_fitness_equilibrium$lifetime<0)])!=0){
  stop("Negative Lifetimes detected")
}
agg<-species_fitness_equilibrium$agg
species_fitness_equilibrium$l_agg<-log(species_fitness_equilibrium$agg)
plot_x<-seq(min(rollmean(sort(log(agg)),k=bin)),max(rollmean(sort(log(agg)),k=bin)),length.out = 100)
min_l_agg<-min(rollmean(sort( species_fitness_equilibrium$l_agg),k=bin))
max_l_agg<-max(rollmean(sort( species_fitness_equilibrium$l_agg),k=bin))

# rm(list=c(setdiff(ls(),"all_species_keep")))
# save.image("all_datap3.RData")
with(species_fitness_equilibrium,
     plot(rollmean(sort(log10(agg)),k=bin),
     rollmean(lifetime[order(log(agg))],k=bin),
     xlab=expression(log(a[i])),ylab="Lifetime",cex=0.1))

# with(species_fitness_equilibrium,
#      plot(rollmean(sort(log(agg)),k=bin),
#           rollmean(fitness[order(log(agg))],k=bin),
#           xlab=expression(log(a[i])),ylab="Lifetime",cex=0.1))

with(all_species_keep,plot(id,n_P,type="l",col="green",xlab="Time-steps",ylab="Species Richness"))
with(all_species_keep,lines(id,n_C,type="l",col="red",ylim=c(0,max(n_P))))


# Numeric Analysis: Lifetime, Birth rate and Fitness ######

for_nls<-species_fitness_equilibrium[order(species_fitness_equilibrium$agg),]
for_nls_birth<-species_fitness_equilibrium[which(species_fitness_equilibrium$lifetime>0),];
for_nls_birth<-for_nls_birth[order(for_nls_birth$agg),]
for_nls_birth$birth_rate<-with(for_nls_birth,fitness/lifetime)
species_fitness_equilibrium$birth_rate<-species_fitness_equilibrium$fitness/(species_fitness_equilibrium$lifetime+1)
for_nls_birth_m<-data.frame(with(for_nls_birth,rollmean(birth_rate[order(agg)],k=bin)))
colnames(for_nls_birth_m)<-"birth_rate"
for_nls_birth_m$agg<-with(for_nls_birth,rollmean(sort(agg),k=bin))

lm_fitness_agg<-lm(fitness ~ log(agg)+I(log(agg)^2),species_fitness_equilibrium)
f_nls_quadratic<-nls(fitness ~ c+b*log(agg)+a*log(agg)^2,for_nls,
                     start=list(c=coef(lm_fitness_agg)[1],b=coef(lm_fitness_agg)[2],a=coef(lm_fitness_agg)[3]))
lm_birth_agg<-lm(birth_rate ~ log10(agg)+I(log10(agg)^2),for_nls_birth_m)
for_nls_birth_m$log10agg<-with(for_nls_birth,rollmean(sort(log10(agg)),k=bin))
b_nls_quadratic<-nls(birth_rate ~ a+b*(log10agg)+c*(log10agg)^2,for_nls_birth_m,
                     start=list(a=coef(lm_birth_agg)[1],b=coef(lm_birth_agg)[2],c=coef(lm_birth_agg)[3]))
paramz61<-coef(b_nls_quadratic)
geom_mean_x<-exp(seq(min(rollmean(sort(log(agg)),k=bin)),max(rollmean(sort(log(agg)),k=bin)),length.out = 1000))
prob<-cubic(log10(geom_mean_x),as.numeric(paramz61[1]),as.numeric(paramz61[2]),as.numeric(paramz61[3]),0)

# Analysis: Frequency of activation #####

num<-20 # Specify number of bins for aggregating activation frequency analysis
agg<-species_fitness_equilibrium$agg
bins<-seq(exp(min_l_agg),exp(max_l_agg),length.out=num)
size<-bins[2]/bins[1]

respp<-unlist(llply(bins,function(x) sum(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),]$extinction == 2)))
spec<-unlist(llply(bins,function(x) sum(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),]$extinction == 1)))
comp<-unlist(llply(bins,function(x) sum(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),]$extinction %in% c(61,62,63))))
over<-unlist(llply(bins,function(x) sum(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),]$extinction == 3)))

# Invader kills residents
comp_61<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],sum(extinction == 61))))
# Resident kills resident (after resource invasion)
comp_62<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],sum(extinction == 62 &
                        lifetime != 0  ))))
comp_62_l0<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],sum(extinction == 62 &
                        lifetime == 0  ))))
# Resident kills resident (after consumer invasion)
comp_63<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],sum(extinction == 63 &
                                                                                                                                                         lifetime != 0  ))))
comp_63_l0<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],sum(extinction == 63 &
                                                                                                                                                             lifetime == 0  ))))
comp_62_63<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],
                                               sum(extinction %in% c(62,63)))))
comp_62_63_l0<-unlist(llply(bins,function(x) with(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),],
                                               sum(extinction %in% c(62,63) & lifetime == 0  ))))
lifetimes<-unlist(llply(bins,function(x) sum(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),]$lifetime)))+1
all<-unlist(llply(bins,function(x) sum(species_fitness_equilibrium[which(species_fitness_equilibrium$agg>x & species_fitness_equilibrium$agg<x*size),]$extinction !=0 )))

###### Analsys: Analytic Birth Rate #####

P_b_m<-K_dt
filez<-list.files(pattern = "HH", recursive = T,full.names = T, path = "/Data/Raw/Deconstructed_assembly_model")
all<-data.frame()
for (i in 1:length(filez)){
  cat(i/length(filez)*100,"%","\r")
  # loop over repetitions
  part1<-strsplit(strsplit(filez[i],".txt")[[1]],"HH")[[1]]
  HH<-as.matrix(read.table(paste(part1[[1]],"HH",as.integer(part1[[2]]),".txt",sep="")));
  aggz<-read.table(paste(part1[[1]],"agg",as.integer(part1[[2]]),".txt",sep=""))
  current<-data.frame(aggz);colnames(current)<-"agg";Sr<-dim(HH)[1]
  # Numeric
  mu_sd<-find_mu_sd(dim(HH)[1],sigmaa)
  mu<-unlist(mu_sd[1]);sd<-unlist(mu_sd[2])
  current$b_p_Axel<-0
  all_b_p<-unlist(llply(aggz$V1, function(x) birth_prob(log(x),mu,sd)))
  current[,2]<-unlist(llply(1:dim(HH)[2],function(x) all_b_p[x]/sum(all_b_p)))
  
  # Numeric with K correction
  current$b_p_Axel_c<-0
  all_b_p_c<-unlist(llply(aggz$V1, function(x) birth_prob_c(log(x),mu,sd)))
  current[,3]<-unlist(llply(1:dim(HH)[2],function(x) all_b_p_c[x]/sum(all_b_p_c)))
  
  # Optimised
  # mu_sd_2<-mu_sd_dt[which(mu_sd_dt$Sr==Sr),]
  # mu_c<-mu_sd_2[1];sd_c<-mu_sd_2[2]
  # current$b_p_Axel_a<-0
  # all_b_p_a<-unlist(llply(aggz$V1, function(x) birth_prob(log(x),mu_c,sd_c)))
  # current[,4]<-unlist(llply(1:dim(HH)[2],function(x) all_b_p_a[x]/sum(all_b_p_a)))
  
  # Optimised with K correction
  # current$b_p_Axel_a_c<-0
  # all_b_p_a_c<-unlist(llply(aggz$V1, function(x) birth_prob_c(log(x),mu_c,sd_c)))
  # current[,5]<-unlist(llply(1:dim(HH)[2],function(x) all_b_p_a_c[x]/sum(all_b_p_a_c)))
  
  current$Sr<-dim(HH)[1]
  all<-rbind(all,current)
}
all<-na.omit(all)

{
  plot(log10(geom_mean_x),log10(prob),type="l",xlab=expression(log(a[i])),ylab="Birth Rate")
  lines(rollmean(sort(log10(all$agg)),k=bin),
        rollmean(log10(all$b_p_Axel[order(all$agg)]),k=bin),
        xlab=expression(log(a[i])),ylab="Birth Rate",cex=0.1,type="l",col="green")
  lines(rollmean(sort(log10(all$agg)),k=bin),
        rollmean( log10(all$b_p_Axel_c[order(log(all$agg))]),k=bin),
        xlab=expression(log(a[i])),ylab="Birth Rate",cex=0.1,lty=2,col="green")
}

##### Distribution with no serial extinction ######

{
  findFitConsumer_tt <- function(agg){
    
    repeat{
      H <- agg*exp(rnorm(Sr,sd=sigma))*K*epsilon/resp
      if(sum(H)>1) break
    }
    return(list(H=H,agg=agg))
  }
  
  serial_extinction_t_iter<-function(linkss,agg,numb_iter){
    linkss<-serial_extinction_t(linkss)
    for (i in 1:numb_iter){
      linkss<- c(linkss,exp(rnorm(1,0,sigma))*exp(agg))
      # if(length(linkss)<Sr){
      #   linkss<- c(linkss,exp(rnorm(Sr-length(linkss),0,sigma))*exp(agg))
      # }else{
      #   repeat{
      #     temp<-linkss
      #     temp[sample(1:length(temp),1)]<- exp(rnorm(1,0,sigma))*exp(agg)
      #     if(sum(temp)>1) break
      #   }
      #   linkss<-temp
      # }
      linkss<-serial_extinction_t(linkss)
    }
    return(linkss)
  }
  
  find_links<-function(agg,HH){
    # par_col_sum_yo<-parColSums(HH)
    # par_col_sum_yo2<-parColSums(HH^2)
    # Sr<-dim(HH)[1]
    # repeat{
      links<-findFitConsumer_tt(exp(agg))$H
    #   t_inv_HH<-t(links)%*%HH
    #   d_a <- !outcompeted(links,t_inv_HH, par_col_sum_yo, par_col_sum_yo2 )
    #   if( d_a ) break;
    # }
    return(links)
  }
  
  listed.files<-list.files(pattern="HH",recursive=T,full.names = T,path = "/Data/Raw/Deconstructed_assembly_model")
  listed.files<-sample(listed.files,min(length(listed.files),200))
  n_loops<-length(listed.files)*1000
  low_l_ine_2_no<-rep(NA,n_loops);low_ij_2_no<-rep(NA,n_loops);low_sum_2_no<-rep(NA,n_loops);low_0_sum_2_no<-rep(NA,n_loops);low_jj_2_no<-rep(NA,n_loops)
  low_l_ine_no<-rep(NA,n_loops);low_ij_no<-rep(NA,n_loops);low_sum_no<-rep(NA,n_loops);low_0_sum_no<-rep(NA,n_loops);low_jj_no<-rep(NA,n_loops)
  high_l_ine_no<-rep(NA,n_loops);high_ij_no<-rep(NA,n_loops);high_sum_no<-rep(NA,n_loops);high_0_sum_no<-rep(NA,n_loops);high_jj_no<-rep(NA,n_loops)
  med_l_ine_no<-rep(NA,n_loops);med_ij_no<-rep(NA,n_loops);med_sum_no<-rep(NA,n_loops);med_0_sum_no<-rep(NA,n_loops);med_jj_no<-rep(NA,n_loops)
  indexxx<-0
  do_serial<-F
  number_competitors_at_entry<-1
  perc_competitors_at_entry<-1
  plot_x<-seq(min_l_agg, max_l_agg,0.01)
  cc<-(range(plot_x)[2]-range(plot_x)[1])/4
  
  
  # Loop through community matrices
  for (i in 1:length(listed.files)){
    
    cat(i/length(listed.files)*100,"\r")
    other_linkss<-read.table(listed.files[i])
    Sr<-dim(other_linkss)[1]
    Sc<-dim(other_linkss)[2]
    
    # Loop through individual consumer in community
    for (j in 1:dim(other_linkss)[2]){
      
      indexxx<-indexxx+1
      # Sample competitors that the pseudo invader has to outcompete so it can enter
      HH<-as.matrix((other_linkss[,-j])[,sample(1:(dim(other_linkss)[2]-1),
                                                round((dim(other_linkss)[2]-1)*perc_competitors_at_entry))])
     
      # Save links of focal resident
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1]+cc),HH)
      
      # Apply serial extinction?
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      
      # Calculate exploitative competition components
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      low_l_ine_no[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      low_ij_no[indexxx]<-Hij
      low_sum_no[indexxx]<-sum(links)
      low_0_sum_no[indexxx]<-sum(other_links)
      low_jj_no[indexxx]<-Hjj
      
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1]+cc*2),HH)
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      low_l_ine_2_no[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      low_ij_2_no[indexxx]<-Hij
      low_sum_2_no[indexxx]<-sum(links)
      low_0_sum_2_no[indexxx]<-sum(other_links)
      low_jj_2_no[indexxx]<-Hjj
      
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1])+cc*3,HH)
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      med_l_ine_no[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      med_ij_no[indexxx]<-Hij
      med_sum_no[indexxx]<-sum(links)
      med_0_sum_no[indexxx]<-sum(other_links)
      med_jj_no[indexxx]<-Hjj
      
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1])+cc*4,HH)
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      high_l_ine_no[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      high_ij_no[indexxx]<-Hij
      high_sum_no[indexxx]<-sum(links)
      high_0_sum_no[indexxx]<-sum(other_links)
      high_jj_no[indexxx]<-Hjj
    }
  }
  
  par(mar=c(4,0,0,4))
  cex.labs<-2
  plot(density((na.omit(low_l_ine_no)),bw=bww),col=colz[1],main="",lwd=lwdd,
       yaxt="n",ylab="",xlab="",
       cex.axis=cex.labs,cex.lab=cex.labs,xlim=c(-1,1),ylim=c(0,0.07))
  lines(density((na.omit(low_l_ine_2_no)),bw=bww),col=colz[2],lwd=lwdd)
  lines(density((na.omit(med_l_ine_no)),bw=bww),col=colz[3],lwd=lwdd)
  lines(density((na.omit(high_l_ine_no)),bw=bww),col=colz[4],lwd=lwdd)
  axis(4,cex.axis=cex.labs,cex.lab=cex.labs)
  
  # Whats missing?  Doesn't make sense that we add so many resouces
  low_l_ine_2<-rep(NA,n_loops);low_ij_2<-rep(NA,n_loops);low_sum_2<-rep(NA,n_loops);low_0_sum_2<-rep(NA,n_loops);low_jj_2<-rep(NA,n_loops)
  low_l_ine<-rep(NA,n_loops);low_ij<-rep(NA,n_loops);low_sum<-rep(NA,n_loops);low_0_sum<-rep(NA,n_loops);low_jj<-rep(NA,n_loops)
  high_l_ine<-rep(NA,n_loops);high_ij<-rep(NA,n_loops);high_sum<-rep(NA,n_loops);high_0_sum<-rep(NA,n_loops);high_jj<-rep(NA,n_loops)
  med_l_ine<-rep(NA,n_loops);med_ij<-rep(NA,n_loops);med_sum<-rep(NA,n_loops);med_0_sum<-rep(NA,n_loops);med_jj<-rep(NA,n_loops)
  do_serial<-T
  indexxx<-0

  for (i in 1:length(listed.files)){
    cat(i/length(listed.files)*100,"\r")
    other_linkss<-read.table(listed.files[i])
    Sr<-dim(other_linkss)[1]
    Sc<-dim(other_linkss)[2]
    
    # Loop through individual consumer in community
    for (j in 1:dim(other_linkss)[2]){
      
      indexxx<-indexxx+1
      # Sample competitors that the pseudo invader has to outcompete so it can enter
      HH<-as.matrix((other_linkss[,-j])[,sample(1:(dim(other_linkss)[2]-1),
                                                round((dim(other_linkss)[2]-1)*perc_competitors_at_entry))])
      par_col_sum_yo<-parColSums(HH)
      par_col_sum_yo2<-parColSums(HH^2)
      
      # Save links of focal resident
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1]+cc),HH)
      
      # Apply serial extinction?
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      
      # Calculate exploitative competition components
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      low_l_ine[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      low_ij[indexxx]<-Hij
      low_sum[indexxx]<-sum(links)
      low_0_sum[indexxx]<-sum(other_links)
      low_jj[indexxx]<-Hjj
      
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1]+cc*2),HH)
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      low_l_ine_2[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      low_ij_2[indexxx]<-Hij
      low_sum_2[indexxx]<-sum(links)
      low_0_sum_2[indexxx]<-sum(other_links)
      low_jj_2[indexxx]<-Hjj
      
      
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1]+cc*3),HH)
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      med_l_ine[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      med_ij[indexxx]<-Hij
      med_sum[indexxx]<-sum(links)
      med_0_sum[indexxx]<-sum(other_links)
      med_jj[indexxx]<-Hjj
      
      
      other_links<-other_linkss[,j]
      links<-find_links(exp(range(plot_x)[1]+cc*4),HH)
      if(do_serial){
        links<- serial_extinction_t(links)
        other_links<-other_links[1:length(links)]
      }
      Hij<-sum(links*other_links)
      Hjj<-sum(other_links^2)
      high_l_ine[indexxx]<-log10(sum(links)-1)-log10(Hij)-log10(sum(other_links)-1)+log10(Hjj)
      high_ij[indexxx]<-Hij
      high_sum[indexxx]<-sum(links)
      high_0_sum[indexxx]<-sum(other_links)
      high_jj[indexxx]<-Hjj
    }
  }
}

#### End ####
save.image("Data/Pre_processed/Data_deconstructed.RData")

