<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - NewWeb.info - build/NetworkHelpers.cc</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">build</a> - NetworkHelpers.cc<span style="font-size: 80%;"> (source / <a href="NetworkHelpers.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">NewWeb.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">673</td>
            <td class="headerCovTableEntryLo">0.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-05-14 13:23:03</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">35</td>
            <td class="headerCovTableEntryLo">5.7 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // $Id: NetworkHelpers.cc 2351 2013-12-18 21:10:51Z axel $</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : #include &lt;set&gt;
<span class="lineNum">       4 </span>            : #include &lt;list&gt;
<span class="lineNum">       5 </span>            : #include &lt;stack&gt;
<span class="lineNum">       6 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">       7 </span>            : #include &lt;cmath&gt;
<span class="lineNum">       8 </span>            : #include &quot;NetworkAnalysis.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;CMatrix.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;Statistics.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;random.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : // We also use the BOOST generic functions 
<span class="lineNum">      14 </span>            : #include &lt;boost/graph/vector_as_graph.hpp&gt; // Boost bug #2119
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #ifndef BOOST_VERSION 
<span class="lineNum">      17 </span>            : #include &lt;boost/version.hpp&gt; 
<span class="lineNum">      18 </span>            : #endif 
<span class="lineNum">      19 </span>            : #if BOOST_VERSION &gt; 104100 
<span class="lineNum">      20 </span>            : #warning --------- FIXME ----------
<span class="lineNum">      21 </span>            : #warning YOU HAVE A BOOST VERSION LATER THAN 1.41
<span class="lineNum">      22 </span>            : #warning THIS CODE WILL COMPILE BUT NETWORK HELPERS MIGHT GIVE 
<span class="lineNum">      23 </span>            : #warning AN ERROR MESSEAG WHEN EXECUTED.
<span class="lineNum">      24 </span>            : #warning --------- END FIXME ------
<span class="lineNum">      25 </span>            : #include &lt;boost/graph/adjacency_matrix.hpp&gt;
<span class="lineNum">      26 </span>            : #else // adjacency_matrix needs some fixing in older versions:
<span class="lineNum">      27 </span>            : #if BOOST_VERSION &lt;= 104100 
<span class="lineNum">      28 </span>            : #include &quot;my_adjacency_matrix.hpp&quot;
<span class="lineNum">      29 </span>            : #else
<span class="lineNum">      30 </span>            : #error my_adjacency_matrix.hpp will not work with latest versions of boost :(
<span class="lineNum">      31 </span>            : #endif
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &lt;boost/graph/topological_sort.hpp&gt;
<span class="lineNum">      35 </span>            : #include &lt;boost/graph/connected_components.hpp&gt;
<span class="lineNum">      36 </span>            : #include &lt;boost/graph/strong_components.hpp&gt;
<span class="lineNum">      37 </span>            : #include &lt;boost/version.hpp&gt;
<span class="lineNum">      38 </span>            : #if BOOST_VERSION &gt;= 104000 
<span class="lineNum">      39 </span>            : #include &lt;boost/property_map/vector_property_map.hpp&gt;
<span class="lineNum">      40 </span>            : #else
<span class="lineNum">      41 </span>            : #include &lt;boost/vector_property_map.hpp&gt;
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : #include &lt;boost/graph/transitive_closure.hpp&gt;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : ///////// This does not seem to be necessary anymore???
<span class="lineNum">      46 </span>            : // // Finally we include the very beautiful 
<span class="lineNum">      47 </span>            : // #if BOOST_VERSION == 104000 
<span class="lineNum">      48 </span>            : // #include &lt;/home/arossberg/include/boost/foreach.hpp&gt;
<span class="lineNum">      49 </span>            : // #else
<span class="lineNum">      50 </span>            : #include &lt;boost/foreach.hpp&gt;
<span class="lineNum">      51 </span>            : // #endif
<span class="lineNum">      52 </span>            : #include &lt;boost/version.hpp&gt;
<span class="lineNum">      53 </span>            :   
<span class="lineNum">      54 </span>            : namespace boost {
<span class="lineNum">      55 </span>            :     
<span class="lineNum">      56 </span>            : #if BOOST_VERSION != 104900
<span class="lineNum">      57 </span>            :   namespace BOOST_FOREACH = foreach;
<span class="lineNum">      58 </span>            : #endif
<span class="lineNum">      59 </span>            :  
<span class="lineNum">      60 </span>            : } // namespace boost
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : // and rename it to
<span class="lineNum">      64 </span>            : #define foreach BOOST_FOREACH
<span class="lineNum">      65 </span>            : // and alternatively to
<span class="lineNum">      66 </span>            : #define forall BOOST_FOREACH
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : // Here we (nearly) allways use the following implementation of a
<span class="lineNum">      70 </span>            : // graph:
<span class="lineNum">      71 </span>            : #include &lt;boost/graph/adjacency_list.hpp&gt;
<span class="lineNum">      72 </span>            : typedef boost::
<span class="lineNum">      73 </span>            : adjacency_list&lt;boost::listS, boost::vecS, boost::bidirectionalS&gt; Graph;
<span class="lineNum">      74 </span>            : typedef boost::
<span class="lineNum">      75 </span>            : graph_traits&lt;Graph&gt;::edge_descriptor edge;
<span class="lineNum">      76 </span>            : typedef boost::
<span class="lineNum">      77 </span>            : graph_traits&lt;Graph&gt;::vertex_descriptor node;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : // ... but sometimes we shall also need undirected graphs ...
<span class="lineNum">      80 </span>            : typedef boost::
<span class="lineNum">      81 </span>            : adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; ugraph;
<span class="lineNum">      82 </span>            : typedef boost::
<span class="lineNum">      83 </span>            : graph_traits&lt;ugraph&gt;::edge_descriptor uedge;
<span class="lineNum">      84 </span>            : typedef boost::
<span class="lineNum">      85 </span>            : graph_traits&lt;ugraph&gt;::vertex_descriptor unode;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : // ... perhaps made from directed graphs ...
<span class="lineNum">      88 </span><span class="lineNoCov">          0 : ugraph to_ugraph(const Graph&amp; G){</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   ugraph ug(num_vertices(G));</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   forall(e,edges(G)){</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     add_edge(unode(source(e,G)),unode(target(e,G)),ug);</span>
<span class="lineNum">      93 </span>            :   }
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   return ug;</span>
<span class="lineNum">      95 </span>            : }
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : inline void NODE_REPORT(const node &amp; centernode,const Graph &amp; G){
<span class="lineNum">      99 </span>            : #if 0
<span class="lineNum">     100 </span>            :   edge e;
<span class="lineNum">     101 </span>            :   REPORT(centernode);
<span class="lineNum">     102 </span>            :   forall(e,in_edges(centernode,G)){
<span class="lineNum">     103 </span>            :     REPORT(source(e,G));
<span class="lineNum">     104 </span>            :   }
<span class="lineNum">     105 </span>            :   forall(e,out_edges(centernode,G)){
<span class="lineNum">     106 </span>            :     REPORT(target(e,G));
<span class="lineNum">     107 </span>            :   }
<span class="lineNum">     108 </span>            : #endif
<span class="lineNum">     109 </span>            : }
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : // #ifndef REVERSE_GRAPH_DWA092300_H_
<span class="lineNum">     113 </span>            : // asdf;
<span class="lineNum">     114 </span>            : // #endif
<span class="lineNum">     115 </span>            : // #ifdef BOOST_SUBGRAPH_HPP
<span class="lineNum">     116 </span>            : // asdfads;
<span class="lineNum">     117 </span>            : // #endif
<span class="lineNum">     118 </span>            : // #ifdef BOOST_FILTERED_GRAPH_HPP
<span class="lineNum">     119 </span>            : // asdfkdk;
<span class="lineNum">     120 </span>            : // #endif
<span class="lineNum">     121 </span>            : // #ifdef BOOST_VECTOR_AS_GRAPH_HPP
<span class="lineNum">     122 </span>            : // kkcj;
<span class="lineNum">     123 </span>            : // #endif
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : #if defined(ON_SX5FSV) || defined(SX)
<span class="lineNum">     127 </span>            : #include &lt;ieeefp.h&gt;
<span class="lineNum">     128 </span>            : //#define isinf(X) (((X)+1)==(X)) //quick and dirty
<span class="lineNum">     129 </span>            : inline bool isinf(double f){
<span class="lineNum">     130 </span>            :   int cl=fpclass(f);
<span class="lineNum">     131 </span>            :   return cl==FP_NINF || cl==FP_PINF;
<span class="lineNum">     132 </span>            : }
<span class="lineNum">     133 </span>            : #endif
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : //#define forall_set_elements(E,SET) for((E)=(SET).choose();!(SET).empty();(SET).del(E),(E)=(SET).choose())
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : Interaction_Matrix forgiving_tsort(Interaction_Matrix &amp;     m){</span>
<span class="lineNum">     139 </span>            :   // Implements the &quot;greedy&quot; algorithm to approximate maximal acyclic
<span class="lineNum">     140 </span>            :   // subgraphs. There are better algorithms, but they are more
<span class="lineNum">     141 </span>            :   // complex.  For now, this might be enough.
<span class="lineNum">     142 </span>            :   
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   Graph G(m.size());</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   permutation p(m.size());</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   // Add edges one after the other, but only if graph remains acyclic:
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats){</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         edge e=add_edge(i,j,G).first;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :         try {
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :           topological_sort(G,p.begin());</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         }catch(boost::not_a_dag){</span>
<span class="lineNum">     156 </span>            :           //graph is not cyclic
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :           remove_edge(e,G);</span>
<span class="lineNum">     158 </span>            :         }         
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :       }
<span class="lineNum">     161 </span>            :     }
<span class="lineNum">     162 </span>            :   }
<span class="lineNum">     163 </span>            :     
<span class="lineNum">     164 </span>            :   // G is now an approximate maximal acyclic subgraph of the food web
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   topological_sort(G,p.begin());</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   permutation p2(m.size());</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     p2[p[(m.size()-1)-i]]=i;</span>
<span class="lineNum">     170 </span>            :   }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   return m.permute(p2);</span>
<span class="lineNum">     173 </span>            : }
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : typedef Interaction_Matrix::histogram histogram;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : // These are global static for speed:
<span class="lineNum">     178 </span><span class="lineCov">         45 : static std::simple_vector&lt;int&gt; passed;</span>
<span class="lineNum">     179 </span><span class="lineCov">         45 : static Graph G; </span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : //histogram accumulate_chains(const node n)__attribute__((pure));
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : // helper for loop_free_chain_hist:
<span class="lineNum">     184 </span><span class="lineNoCov">          0 : histogram accumulate_chains(const node n){</span>
<span class="lineNum">     185 </span>            :   // histogram of chain lengths of chains starting from n
<span class="lineNum">     186 </span>            :   // and not passing through passed.
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   int &amp; passed_here = passed[n];</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   if(passed_here) </span>
<span class="lineNum">     191 </span>            :     return histogram(); // drop chains with loops
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   histogram sum;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   passed_here=true;</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   foreach(e,in_edges(n, G)){</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     sum+=accumulate_chains(source(e,G));</span>
<span class="lineNum">     199 </span>            :   }
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   passed_here=false;</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   sum.prepend(1);</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   return sum;</span>
<span class="lineNum">     204 </span>            : }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : histogram loop_free_chain_hist(Interaction_Matrix &amp; m){</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   G=Graph(m.size());</span>
<span class="lineNum">     209 </span>            :   
<span class="lineNum">     210 </span>            :   // build the graph
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span>            :   }
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   std::set&lt;node&gt; bottom_species;</span>
<span class="lineNum">     219 </span>            :   
<span class="lineNum">     220 </span>            :   // get the bottom species
<span class="lineNum">     221 </span>            :   node n;
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     if(out_degree(n,G)==0)</span>
<span class="lineNum">     224 </span>            :       bottom_species.insert(n);
<span class="lineNum">     225 </span>            :   }
<span class="lineNum">     226 </span>            :     
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   histogram sum;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   passed=std::simple_vector&lt;int&gt;(num_vertices(G));</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :   forall(n,bottom_species){</span>
<span class="lineNum">     232 </span>            :     // the main work is done in this recursive function:
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     sum+=accumulate_chains(n);</span>
<span class="lineNum">     234 </span>            :   }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   // this is probably wrong:
<span class="lineNum">     237 </span>            : //   // by convention, there are no chains of length 0;
<span class="lineNum">     238 </span>            : //   histogram result(sum.size()+1,0);
<span class="lineNum">     239 </span>            : //   copy(sum.begin(),sum.end(),&amp;result[1]);
<span class="lineNum">     240 </span>            : //   return result; 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   return sum;</span>
<span class="lineNum">     242 </span>            : }
<span class="lineNum">     243 </span>            :                         
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :         
<span class="lineNum">     246 </span>            : // This referes to loops in the graph theoretical sense:
<span class="lineNum">     247 </span>            : // but the Food-Web sense seems to be different.
<span class="lineNum">     248 </span>            :         
<span class="lineNum">     249 </span>            : ////////// LEDA manual citation:
<span class="lineNum">     250 </span>            : // int STRONG_COMPONENTS(graph&amp; G, node_array&lt;int&gt;&amp; compnum) 
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : // STRONG_COMPONENTS takes a directed graph G(V,E) as argument and
<span class="lineNum">     253 </span>            : // computes for every node v V an integer compnum[v] from [0 ...c - 1]
<span class="lineNum">     254 </span>            : // where c is the number of strongly connected components of G and v
<span class="lineNum">     255 </span>            : // belongs to the i-th strongly connected component iff compnum[v] =
<span class="lineNum">     256 </span>            : // i. STRONG_COMPONENTS returns c.  The algorithm ([36]) has running
<span class="lineNum">     257 </span>            : // time O(|V| + |E|).
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : double real_loop_species_fraction(Interaction_Matrix &amp; m){</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   G=Graph(m.size());</span>
<span class="lineNum">     262 </span>            :   
<span class="lineNum">     263 </span>            :   // build the graph
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            :   }
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :   // compute strongly connected components:
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   boost::vector_property_map&lt;int&gt; compnum(num_vertices(G));</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   strong_components(G, compnum);</span>
<span class="lineNum">     274 </span>            :   
<span class="lineNum">     275 </span>            :   // compute the size of each component
<span class="lineNum">     276 </span>            :   node n;
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   histogram comp_size;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     int c=compnum[n];</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     comp_size[c]++;</span>
<span class="lineNum">     281 </span>            :   }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   
<span class="lineNum">     284 </span>            :   // species contained in loops are in components with more than one
<span class="lineNum">     285 </span>            :   // element:
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     int c=compnum[n];</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if(comp_size[c]&gt;1)</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       count++;</span>
<span class="lineNum">     291 </span>            :   }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   return double(count)/m.size();</span>
<span class="lineNum">     294 </span>            : }
<span class="lineNum">     295 </span>            :         
<span class="lineNum">     296 </span>            : // helper for omnivore_fraction:
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : //// This definition is counterintuitive, but Williams et al Nature, 2000:
<span class="lineNum">     299 </span>            : // &quot;Omnivory [5] is the fraction of species that consume two or more
<span class="lineNum">     300 </span>            : // species and have food chains of different lengths (Omniv).&quot;
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineCov">         45 : static std::simple_vector&lt;int&gt; unique_chain_length;</span>
<span class="lineNum">     303 </span>            : enum unique_chain_length_special_value {not_unique=-1,unset=0};
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : int check_unique_chain_length(const node n){</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   int &amp; passed_here=passed[n];</span>
<span class="lineNum">     307 </span>            :   // here is a design option:
<span class="lineNum">     308 </span>            :   if(0){
<span class="lineNum">     309 </span>            :     if(passed_here) return unique_chain_length[n]=unset;
<span class="lineNum">     310 </span>            :   }else{
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     if(passed_here) return unique_chain_length[n]=not_unique;</span>
<span class="lineNum">     312 </span>            :   }
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   if(unique_chain_length[n]!=unset) return unique_chain_length[n];</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : //   // since unset==0, we do not need this:
<span class="lineNum">     316 </span>            : //   if(G.outdeg(n)==0)
<span class="lineNum">     317 </span>            : //     return unique_chain_length[n]=1;
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   int unique_length=unset;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   passed_here=true;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   forall(e,out_edges(n,G)){</span>
<span class="lineNum">     323 </span>            :     int length=
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :       check_unique_chain_length(target(e,G));</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     if(length!=unset){</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :       if(length==not_unique || (unique_length!=unset &amp;&amp; length!=unique_length)){</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         passed_here=false;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         return unique_chain_length[n]=not_unique;</span>
<span class="lineNum">     329 </span>            :       }
<span class="lineNum">     330 </span>            :       unique_length=length;
<span class="lineNum">     331 </span>            :     }
<span class="lineNum">     332 </span>            :   }
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   passed_here=false;</span>
<span class="lineNum">     334 </span>            :   
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   return unique_chain_length[n]=1+unique_length;</span>
<span class="lineNum">     336 </span>            : }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :                 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 : double omnivore_fraction(Interaction_Matrix &amp; m){</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   G=Graph(m.size());</span>
<span class="lineNum">     341 </span>            :   
<span class="lineNum">     342 </span>            :   // build the graph
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">     347 </span>            :     }
<span class="lineNum">     348 </span>            :   }
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   passed=std::simple_vector&lt;int&gt;(m.size());</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   unique_chain_length=std::simple_vector&lt;int&gt;(m.size(),unset);</span>
<span class="lineNum">     352 </span>            :   node n;
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     check_unique_chain_length(n);</span>
<span class="lineNum">     355 </span>            :   }
<span class="lineNum">     356 </span>            :   
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if(out_degree(n,G)&gt;1 &amp;&amp; unique_chain_length[n]==not_unique)</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       count++;</span>
<span class="lineNum">     361 </span>            :   }
<span class="lineNum">     362 </span>            :   
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   return double(count)/m.size();</span>
<span class="lineNum">     364 </span>            : }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : enum {loopy=-1, not_loopy=1};
<span class="lineNum">     367 </span>            : static std::simple_vector&lt;int&gt; &amp; loopiness =unique_chain_length; 
<span class="lineNum">     368 </span>            : // reuse this variable
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : int check_loopy(const node n){</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   int &amp; passed_here=passed[n];</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   if(passed_here) return loopiness[n]=loopy;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   if(loopiness[n]!=unset) return loopiness[n];</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   passed_here=true;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   forall(e,out_edges(n,G)){</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     if(target(e,G)!=n){</span>
<span class="lineNum">     379 </span>            :       int l=
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         check_loopy(target(e,G));</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       if(l==loopy){</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         passed_here=false;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         return loopiness[n]=loopy;</span>
<span class="lineNum">     384 </span>            :       }
<span class="lineNum">     385 </span>            :     }
<span class="lineNum">     386 </span>            :   }
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   passed_here=false;</span>
<span class="lineNum">     388 </span>            :   
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   return loopiness[n]=not_loopy;</span>
<span class="lineNum">     390 </span>            : }
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineNoCov">          0 : double loop_species_fraction(Interaction_Matrix &amp; m){</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   G=Graph(m.size());</span>
<span class="lineNum">     395 </span>            :   
<span class="lineNum">     396 </span>            :   // build the graph
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">     401 </span>            :     }
<span class="lineNum">     402 </span>            :   }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   passed=std::simple_vector&lt;int&gt;(m.size(),false);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   loopiness=std::simple_vector&lt;int&gt;(m.size(),unset);</span>
<span class="lineNum">     406 </span>            :   node n;
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     if(check_loopy(n)==loopy) count++;</span>
<span class="lineNum">     410 </span>            :   }
<span class="lineNum">     411 </span>            :   
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   return double(count)/m.size();</span>
<span class="lineNum">     413 </span>            : }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineNoCov">          0 : bool is_connected(Interaction_Matrix &amp; m){</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   G=Graph(m.size());</span>
<span class="lineNum">     417 </span>            :   
<span class="lineNum">     418 </span>            :   // build the graph
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            :   }
<span class="lineNum">     425 </span>            :   
<span class="lineNum">     426 </span>            :   // compute connected components:
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   boost::vector_property_map&lt;int&gt; compnum(num_vertices(G));</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   return 1==connected_components(to_ugraph(G), compnum);</span>
<span class="lineNum">     429 </span>            : }
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineNoCov">          0 : Interaction_Matrix the_largest_connected_subweb(const Interaction_Matrix &amp; m){</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   Graph G(m.size()); </span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">     438 </span>            :     }
<span class="lineNum">     439 </span>            :   }
<span class="lineNum">     440 </span>            :   
<span class="lineNum">     441 </span>            :   // compute connected components:
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   boost::vector_property_map&lt;int&gt; compnum(num_vertices(G));</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   int n_components=connected_components(to_ugraph(G), compnum);</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   // if only one component, return:
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   if(n_components==1) return m;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :   // find the largest component:
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   histogram component_size(n_components,0);</span>
<span class="lineNum">     450 </span>            :   node n;
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   int largest=0;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   double max_size=0;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     if(++component_size[compnum[n]]&gt;max_size){</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       largest=compnum[n];</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       max_size=component_size[largest];</span>
<span class="lineNum">     457 </span>            :     }
<span class="lineNum">     458 </span>            :   }
<span class="lineNum">     459 </span>            :   
<span class="lineNum">     460 </span>            :   // reduce interaction matrix to largest component:
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;bool&gt; selection(m.size(),false);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     if(compnum[n]==largest)</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :       selection[n]=true;</span>
<span class="lineNum">     465 </span>            :   }
<span class="lineNum">     466 </span>            :   
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   return m.select(selection);</span>
<span class="lineNum">     468 </span>            : }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : // helpers for graph_analyze:
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : typedef std::list&lt; std::pair&lt;node,node&gt; &gt; mini_loop_list_t;
<span class="lineNum">     473 </span>            : typedef Interaction_Matrix::distribution distribution;
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : histogram directed_food_chains_from(node n,</span>
<span class="lineNum">     476 </span>            :                                     const Graph &amp; ASG,
<span class="lineNum">     477 </span>            :                                     std::simple_vector&lt;histogram&gt; &amp; 
<span class="lineNum">     478 </span>            :                                     chains_from){
<span class="lineNum">     479 </span>            :   // perhaps we already computed this
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   if(chains_from[n].size()) return chains_from[n]; </span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   histogram sum;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   forall(e,in_edges(n,ASG)){</span>
<span class="lineNum">     485 </span>            :     sum+=
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       directed_food_chains_from(source(e,ASG),ASG,</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                                 chains_from);</span>
<span class="lineNum">     488 </span>            :   }
<span class="lineNum">     489 </span>            :   // add one to all chain length and one chain of length 0 to the
<span class="lineNum">     490 </span>            :   // histogram:
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   sum.prepend(1);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   return chains_from[n]=sum;</span>
<span class="lineNum">     493 </span>            : }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 : histogram directed_food_chains_to(node n,</span>
<span class="lineNum">     496 </span>            :                                   const Graph &amp; ASG,
<span class="lineNum">     497 </span>            :                                   std::simple_vector&lt;histogram&gt; &amp; 
<span class="lineNum">     498 </span>            :                                   chains_to){
<span class="lineNum">     499 </span>            :   // perhaps we already computed this
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   if(chains_to[n].size()) return chains_to[n]; </span>
<span class="lineNum">     501 </span>            :   
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   histogram sum;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   forall(e,out_edges(n,ASG)){</span>
<span class="lineNum">     505 </span>            :     sum+=
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :       directed_food_chains_to(target(e,ASG),ASG,</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                               chains_to);</span>
<span class="lineNum">     508 </span>            :   }
<span class="lineNum">     509 </span>            :   // add one to all chain lengths and one chain of length 0 to the
<span class="lineNum">     510 </span>            :   // histogram:
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   sum.prepend(1);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   return chains_to[n]=sum;</span>
<span class="lineNum">     513 </span>            : }
<span class="lineNum">     514 </span>            : 
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">         45 : CMatrix&lt;double&gt; table1(0,0); //make this global for convenice;</span></a>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineNoCov">          0 : void make_table1(int maxdegree){</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   table1=CMatrix&lt;double&gt;(maxdegree+1,maxdegree+2);</span>
<span class="lineNum">     519 </span>            :   ASSERT(table1[0][0]==0);
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   for(int d=1;d&lt;=maxdegree;d++){</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     for(int t=d%2;t&lt;=d;t+=2){</span>
<span class="lineNum">     522 </span>            :       double val=
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         (1.0/(d+1))*</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         (t+(d+t)/2.0*table1[d-1][abs(t-1)]+</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :          (d-t)/2.0*table1[d-1][t+1] );</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       table1[d][t]=val;</span>
<span class="lineNum">     527 </span>            :     }
<span class="lineNum">     528 </span>            :   }
<span class="lineNum">     529 </span>            :   // for debugging:
<span class="lineNum">     530 </span>            : //   printf(&quot;table1:\n&quot;);
<span class="lineNum">     531 </span>            : //   for(int d=0;d&lt;=maxdegree;d++){
<span class="lineNum">     532 </span>            : //     for(int t=0;t&lt;=maxdegree;t++){
<span class="lineNum">     533 </span>            : //       printf(&quot;%3g &quot;,table1[d][t]);
<span class="lineNum">     534 </span>            : //     }
<span class="lineNum">     535 </span>            : //     printf(&quot;\n&quot;);
<span class="lineNum">     536 </span>            : //   }
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     538 </span>            :  
<span class="lineNum">     539 </span>            :  
<span class="lineNum">     540 </span><span class="lineNoCov">          0 : int rho(node v,const Graph &amp; g){</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   int i=in_degree(v,g);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   int o=out_degree(v,g);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   return (i&gt;o ? i : o);</span>
<span class="lineNum">     544 </span>            : }
<span class="lineNum">     545 </span><span class="lineNoCov">          0 : int outdegree_after(node v1, const Graph &amp; G,node v){</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   forall(e,out_edges(v1,G)){</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     if(target(e,G)!=v) count++;</span>
<span class="lineNum">     550 </span>            :   }
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   return count;</span>
<span class="lineNum">     552 </span>            : }
<span class="lineNum">     553 </span>            :       
<span class="lineNum">     554 </span><span class="lineNoCov">          0 : int indegree_after(node v1, const Graph &amp; G,node v){</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   forall(e,in_edges(v1,G)){</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     if(source(e,G)!=v) count++;</span>
<span class="lineNum">     559 </span>            :   }
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   return count;</span>
<span class="lineNum">     561 </span>            : }
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span><span class="lineNoCov">          0 : double table2_val(node v2, const Graph &amp; G,node v1){</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   int dout=outdegree_after(v1,G,v2);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   int din=indegree_after(v1,G,v2);</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   int d=din+dout;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   int t=abs(din-dout);</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   return 0.25*d + 0.5*table1[d][t];</span>
<span class="lineNum">     570 </span>            : }
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 : void fix_tables_at(node n1,</span>
<span class="lineNum">     574 </span>            :                    const Graph &amp; G,
<span class="lineNum">     575 </span>            :                    node n2,
<span class="lineNum">     576 </span>            :                    CMatrix&lt;double&gt; &amp; table2,
<span class="lineNum">     577 </span>            :                    std::simple_vector&lt;double&gt; &amp; sum){
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   if(n1!=n2){</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :     int i1=n1;</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     int i2=n2;</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     sum[i1]-=table2[i1][i2];</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     sum[i1]+=</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       table2[i1][i2]=</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :       table2_val(n1,G,n2);</span>
<span class="lineNum">     585 </span>            :   }
<span class="lineNum">     586 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineNoCov">          0 : void drop_and_fix_tables(edge e,</span>
<span class="lineNum">     589 </span>            :                          Graph &amp; G,
<span class="lineNum">     590 </span>            :                          CMatrix&lt;double&gt; &amp; table2,
<span class="lineNum">     591 </span>            :                          std::simple_vector&lt;double&gt; &amp; sum){
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   node s=source(e,G);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   node t=target(e,G);</span>
<span class="lineNum">     594 </span>            :   node n; //helper
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   sum[s]-=rho(s,G);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   sum[t]-=rho(t,G);</span>
<span class="lineNum">     597 </span>            : #ifdef DEBUGGING
<span class="lineNum">     598 </span>            :   forall(n,vertices(G)){
<span class="lineNum">     599 </span>            :     if(n!=s) ASSERT(fabs(table2[n][s]-table2_val(n,G,s))&lt;0.001);
<span class="lineNum">     600 </span>            :     if(n!=t) ASSERT(fabs(table2[n][t]-table2_val(n,G,t))&lt;0.001);
<span class="lineNum">     601 </span>            :   }
<span class="lineNum">     602 </span>            : #endif
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   remove_edge(e,G);</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   sum[s]+=rho(s,G);</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   sum[t]+=rho(t,G);</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     fix_tables_at(n,G,s,table2,sum);</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     fix_tables_at(n,G,t,table2,sum);</span>
<span class="lineNum">     610 </span>            :   }
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 : }</span>
<a name="613"><span class="lineNum">     613 </span>            : </a>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 : void collect_and_fix_tables(edge e,</span>
<span class="lineNum">     616 </span>            :                             Graph &amp; G,
<span class="lineNum">     617 </span>            :                             Graph &amp; ASG,
<span class="lineNum">     618 </span>            :                             CMatrix&lt;double&gt; &amp; table2,
<span class="lineNum">     619 </span>            :                             std::simple_vector&lt;double&gt; &amp; sum){
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   add_edge(source(e,G),target(e,G),ASG);</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   drop_and_fix_tables(e,G,table2,sum);</span>
<a name="622"><span class="lineNum">     622 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     623 </span>            :                
<span class="lineNum">     624 </span><span class="lineNoCov">          0 : int loop_count(Interaction_Matrix &amp; m){</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;i;j++){</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats){</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         count++;</span>
<span class="lineNum">     630 </span>            :       }
<span class="lineNum">     631 </span>            :     }
<span class="lineNum">     632 </span>            :   }
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   return count;</span>
<a name="634"><span class="lineNum">     634 </span>            : }</a>
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineNoCov">          0 : void check_consistency(const Graph &amp; G){</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :   WARNING(&quot;check_consistency(Graph &amp; G) is disabled&quot;);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     639 </span>            : //   LEDA_list&lt;edge&gt; el=G.all_edges();
<span class="lineNum">     640 </span>            : //   node n;
<span class="lineNum">     641 </span>            : //   forall_nodes(n,G){
<span class="lineNum">     642 </span>            : //     edge e;
<span class="lineNum">     643 </span>            : //     forall_in_edges(e,n)
<span class="lineNum">     644 </span>            : //       ASSERT(el.search(e)!=nil);
<span class="lineNum">     645 </span>            : //     forall_out_edges(e,n)
<span class="lineNum">     646 </span>            : //       ASSERT(el.search(e)!=nil);
<span class="lineNum">     647 </span>            : //   }
<span class="lineNum">     648 </span>            : }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : class random_const {
<span class="lineNum">     651 </span>            :   const unsigned int _value;
<span class="lineNum">     652 </span>            : public:
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   random_const(unsigned int dummy=0) : _value(rand()){};</span>
<span class="lineNum">     654 </span>            :   operator const unsigned int &amp;() const{
<span class="lineNum">     655 </span>            :     return _value;
<span class="lineNum">     656 </span>            :   }
<span class="lineNum">     657 </span>            :   //be immune to assignent:
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   random_const(const random_const &amp; other) : _value(rand()){};</span>
<span class="lineNum">     659 </span>            :   random_const&amp; operator=(const random_const&amp;){return *this;};
<span class="lineNum">     660 </span>            : };
<span class="lineNum">     661 </span>            :   
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineNoCov">          0 : unsigned int graph_hash(const Graph &amp; ASG){</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   static sequence&lt;random_const&gt; id;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   id.resize(num_vertices(ASG)); //make sure id values won't change</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :   unsigned int h=0;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :   const unsigned int top_bit=(unsigned(1)&lt;&lt;(8*sizeof(h)-1));</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :   for(unsigned int i=0;i&lt;id.size();i++){</span>
<span class="lineNum">     669 </span>            :     node n;
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     forall(n,adjacent_vertices(i,ASG)){</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :       h^=id[n];</span>
<span class="lineNum">     672 </span>            :     }
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     h+=i;</span>
<span class="lineNum">     674 </span>            :     if(h | top_bit)
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :       h=(h&lt;&lt;1)|1;</span>
<span class="lineNum">     676 </span>            :     else
<span class="lineNum">     677 </span>            :       h&lt;&lt;=1;
<span class="lineNum">     678 </span>            :   }
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :   return h;</span>
<span class="lineNum">     680 </span>            : }
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            : // void mark_followers(const node n, const graph &amp; ASG,
<span class="lineNum">     683 </span>            : //                  follows_t &amp; follows){
<span class="lineNum">     684 </span>            : //   if(passed[n]) return;
<span class="lineNum">     685 </span>            :   
<span class="lineNum">     686 </span>            : //   node m;
<span class="lineNum">     687 </span>            : //   forall_adj_nodes(m,n){
<span class="lineNum">     688 </span>            : //     mark_followers(m,ASG,follows);
<span class="lineNum">     689 </span>            : //     node i;
<span class="lineNum">     690 </span>            : //     forall_nodes(i,ASG){
<span class="lineNum">     691 </span>            : //       follows(n,i)|=follows(m,i);
<span class="lineNum">     692 </span>            : // //       std::cout &lt;&lt; follows(n,i);
<span class="lineNum">     693 </span>            : //     }
<span class="lineNum">     694 </span>            : // //     std::cout &lt;&lt; std::endl;
<span class="lineNum">     695 </span>            : //     follows(n,m)=true;
<span class="lineNum">     696 </span>            : //   }
<span class="lineNum">     697 </span>            : //   passed[n]=true;
<span class="lineNum">     698 </span>            : // }
<span class="lineNum">     699 </span>            :   
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            : // follows_t transitive_closure(const GRAPH&lt;int,int&gt; &amp; ASG){
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : //   follows_t follows(ASG,false);
<span class="lineNum">     704 </span>            : //   passed=node_array&lt;bool&gt;(ASG,false);
<span class="lineNum">     705 </span>            :   
<span class="lineNum">     706 </span>            : //   node n;
<span class="lineNum">     707 </span>            : //   forall_nodes(n,ASG){
<span class="lineNum">     708 </span>            : //     if(ASG.indeg(n)==0){
<span class="lineNum">     709 </span>            : //       mark_followers(n,ASG,follows);
<span class="lineNum">     710 </span>            : //     }
<span class="lineNum">     711 </span>            : //   }
<span class="lineNum">     712 </span>            : // //   forall_nodes(n,ASG){
<span class="lineNum">     713 </span>            : // //     node m;
<span class="lineNum">     714 </span>            : // //     forall_nodes(m,ASG){
<span class="lineNum">     715 </span>            : // //       std::cout &lt;&lt; follows(n,m) ;
<span class="lineNum">     716 </span>            : // //     }
<span class="lineNum">     717 </span>            : // //     std::cout &lt;&lt; &quot; &quot; &lt;&lt; ASG.inf(n) &lt;&lt; std::endl;
<span class="lineNum">     718 </span>            : // //   }
<span class="lineNum">     719 </span>            : //   return follows;
<span class="lineNum">     720 </span>            : // }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            : 
<a name="723"><span class="lineNum">     723 </span>            : typedef boost::adjacency_matrix&lt;&gt; follows_t;</a>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineNoCov">          0 : follows_t transitive_closure(const Graph &amp; ASG){</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   follows_t follows(0);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   boost::transitive_closure(ASG,follows);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   return follows;</span>
<span class="lineNum">     729 </span>            : }
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            : typedef std::list&lt;int&gt; left_multiplicities_list_t;
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineNoCov">          0 : graphs_stats_data graph_analyze(Interaction_Matrix &amp; m, </span>
<span class="lineNum">     734 </span>            :                                 const bool go_through_multiplicities){
<span class="lineNum">     735 </span>            :   //m=m.randomize(); // turn this on to get many multiplicities
<span class="lineNum">     736 </span>            :   //m.Print();
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :   average_meter oChnLg, oChnSD, oChnNo, oLoop, oOmniv;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   graphs_stats_data stats;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   left_multiplicities_list_t multiplicities_left;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   std::set&lt;unsigned int&gt; hashs_of_graphs_found_so_far;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   unsigned int Ghash=0; // to verify if we allways start with the same G</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :   // This loops goes through all possible outcomes of the Berger-Shor
<span class="lineNum">     745 </span>            :   // Algorithm in order to average over them.  In most cases, however,
<span class="lineNum">     746 </span>            :   // the outcome is unique.
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   do{</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     unsigned int multiplicity_index=0;</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     Graph G(m.size()),ASG(m.size()); </span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     std::vector&lt;bool&gt; vertex_alife(m.size(),true);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     int vertices_alife=m.size();</span>
<span class="lineNum">     753 </span>            :   
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     mini_loop_list_t mini_loops;</span>
<span class="lineNum">     755 </span>            :   
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         if((int)m[i][j]==(int)NetworkAnalysis::eats){</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :           if((int)m[j][i]==(int)NetworkAnalysis::eats){</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :             if(i&lt;=j){</span>
<span class="lineNum">     761 </span>            :               // 2-loops and 1-loops:
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :               mini_loops.push_back(std::pair&lt;node,node&gt;(i,j));</span>
<span class="lineNum">     763 </span>            :             }
<span class="lineNum">     764 </span>            :           }else{
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :             add_edge(i,j,G);</span>
<span class="lineNum">     766 </span>            :           }
<span class="lineNum">     767 </span>            :         }
<span class="lineNum">     768 </span>            :       }
<span class="lineNum">     769 </span>            :     }
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :     // check consistency:
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :     if(multiplicities_left.size()==0)</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :       Ghash=graph_hash(G);</span>
<span class="lineNum">     774 </span>            :     else
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       ALWAYS_ASSERT(Ghash==graph_hash(G));</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :     // find maximal degree:
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     int maxdegree=0;</span>
<span class="lineNum">     780 </span>            :     node n;
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     forall(n,vertices(G)){</span>
<span class="lineNum">     782 </span>            :       // dead vertices have degree zero, so they will not interfere here
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       int degree=out_degree(n,G)+in_degree(n,G);</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       if(degree&gt;maxdegree) maxdegree=degree;</span>
<span class="lineNum">     785 </span>            :     }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     make_table1(maxdegree);</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     CMatrix&lt;double&gt; table2(m.size(),m.size());</span>
<span class="lineNum">     790 </span>            :     // prepare table2:
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :       for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         table2[i][j]=table2_val(i,G,j);</span>
<span class="lineNum">     794 </span>            :       }
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     //std::simple_vector&lt;double&gt; sum(m.size());
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     sequence&lt;double&gt; sum(m.size());</span>
<span class="lineNum">     799 </span>            :     // prepare array sum:
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       double s=0;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :       s+=rho(i,G);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :       for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         if(j!=i)</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :           s+=table2[i][j];</span>
<span class="lineNum">     806 </span>            :       }
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :       sum[i]=s;</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :     //main loop:
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     while(vertices_alife){</span>
<span class="lineNum">     812 </span>            :       //     node n1,n2;
<span class="lineNum">     813 </span>            :       //     forall_nodes(n1,G){
<span class="lineNum">     814 </span>            :       //       forall_nodes(n2,G){
<span class="lineNum">     815 </span>            :       //        printf(&quot;%6g &quot;,table2[G.inf(n1)][G.inf(n2)]);
<span class="lineNum">     816 </span>            :       //       }
<span class="lineNum">     817 </span>            :       //       printf(&quot;\n&quot;);
<span class="lineNum">     818 </span>            :       //     }
<span class="lineNum">     819 </span>            :       
<span class="lineNum">     820 </span>            :       // separate strong components
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       boost::vector_property_map&lt;int&gt; compnum(num_vertices(G));</span>
<span class="lineNum">     822 </span>            :       int number_of_components=
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         strong_components(G, compnum);</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       if(number_of_components &gt; 1){</span>
<span class="lineNum">     826 </span>            :         // we go a bit humpty dumpty here, because removal of an edge
<span class="lineNum">     827 </span>            :         // of G, as it happens in collect_and_fix_tables( ),
<span class="lineNum">     828 </span>            :         // invalidates the edge range edges(G) in boost.  There should
<span class="lineNum">     829 </span>            :         // definitely be a better way to do this!
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :         edge e;</span>
<span class="lineNum">     831 </span>            :         typedef std::pair&lt;node,node&gt; simple_edge;
<span class="lineNum">     832 </span>            :         typedef std::list&lt; simple_edge &gt; edge_list_t;
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         edge_list_t to_remove;</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :         forall(e,edges(G)){</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :           if(compnum[source(e,G)]!=compnum[target(e,G)]){</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :             to_remove.push_back(simple_edge(source(e,G),target(e,G)));</span>
<span class="lineNum">     837 </span>            :           }
<span class="lineNum">     838 </span>            :         }
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :         forall(simple_edge se,to_remove){</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :           collect_and_fix_tables(boost::edge(se.first,se.second,G).first,</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                                  G,ASG,table2,sum);</span>
<span class="lineNum">     842 </span>            :         }
<span class="lineNum">     843 </span>            :       }
<span class="lineNum">     844 </span>            :     
<span class="lineNum">     845 </span>            :       // in order to canonicalize multiplicity iteration, find strong
<span class="lineNum">     846 </span>            :       // component with node with smallest index:
<span class="lineNum">     847 </span>            :       node n;
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :       int minindex=m.size(); // index of node with smallest index</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :       int min_compnum=0; // component containing this node</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :       forall(n,vertices(G)){</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         if(vertex_alife[n]){</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :           if(n &lt; minindex){</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :             minindex=n;</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :             min_compnum=compnum[n];</span>
<span class="lineNum">     855 </span>            :           }
<span class="lineNum">     856 </span>            :         }
<span class="lineNum">     857 </span>            :       }
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :       //find best nodes to process next (usually only one)
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       std::list&lt;node&gt; best_nodes;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :       double maxE=-1;</span>
<span class="lineNum">     862 </span>            :       //half max difference between &quot;equal&quot; values:
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :       const double delta=1e-10;</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       forall(n,vertices(G)){</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :         if(vertex_alife[n]){</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :           if(compnum[n]==min_compnum){</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :             if(sum[n]&gt;maxE-delta){</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :               if(sum[n]&gt;maxE+delta){</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :                 maxE=sum[n];</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                 best_nodes.clear();</span>
<span class="lineNum">     871 </span>            :                 best_nodes.push_back(n);
<span class="lineNum">     872 </span>            :               }else{
<span class="lineNum">     873 </span>            :                 best_nodes.push_back(n);
<span class="lineNum">     874 </span>            :               }
<span class="lineNum">     875 </span>            :             }
<span class="lineNum">     876 </span>            :           }
<span class="lineNum">     877 </span>            :         }
<span class="lineNum">     878 </span>            :       }
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            :       //REPORT(sum);
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :       sequence&lt;int&gt; is_in_min_comp(m.size(),false);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :       forall(n,vertices(G)){</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :         is_in_min_comp[n]=(compnum[n]==min_compnum);</span>
<span class="lineNum">     884 </span>            :       }
<span class="lineNum">     885 </span>            :       //REPORT(is_in_min_comp);
<span class="lineNum">     886 </span>            :       
<span class="lineNum">     887 </span>            :       
<span class="lineNum">     888 </span>            :       
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       node max_n=*(best_nodes.begin()); //nominally unique maximal node</span>
<span class="lineNum">     890 </span>            :       ASSERT(best_nodes.begin()!=best_nodes.end());
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :       unsigned int bns=best_nodes.size();</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :       if(bns&gt;1 &amp;&amp; go_through_multiplicities){</span>
<span class="lineNum">     893 </span>            : //      REPORT(bns);
<span class="lineNum">     894 </span>            :         //////we detected a multiplicity
<span class="lineNum">     895 </span>            :         int node_to_pick; // this we have to decide now
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :         const unsigned int multiplicity_randomization_threshold=0;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         unsigned int mls=multiplicities_left.size();</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         if(mls==multiplicity_index){</span>
<span class="lineNum">     899 </span>            :           //we have to start iterating over this multiplicity
<span class="lineNum">     900 </span>            :           if(multiplicity_index&gt;=multiplicity_randomization_threshold){
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :             WARNING(&quot;multiplicity_index&gt;=multiplicity_randomization_threshold&quot;);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             multiplicities_left.push_back(0);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :             node_to_pick=random_integer(bns);</span>
<span class="lineNum">     904 </span>            :           }else{
<span class="lineNum">     905 </span>            :             std::cout &lt;&lt; &quot;mult &quot; &lt;&lt; multiplicity_index 
<span class="lineNum">     906 </span>            :                       &lt;&lt; &quot; start &quot; &lt;&lt; bns 
<span class="lineNum">     907 </span>            :                       &lt;&lt; std::endl;
<span class="lineNum">     908 </span>            :             multiplicities_left.push_back(bns-1);
<span class="lineNum">     909 </span>            :           }
<span class="lineNum">     910 </span>            :         }
<span class="lineNum">     911 </span>            :         ////decide which node to pick:
<span class="lineNum">     912 </span>            :         if(multiplicity_index&gt;=multiplicity_randomization_threshold){
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :           node_to_pick=random_integer(bns);</span>
<span class="lineNum">     914 </span>            :         }else{
<span class="lineNum">     915 </span>            :           left_multiplicities_list_t::iterator mult=
<span class="lineNum">     916 </span>            :             multiplicities_left.begin();
<span class="lineNum">     917 </span>            :           //find the multipliticy we are working on 
<span class="lineNum">     918 </span>            :           for(int c=multiplicity_index;c&gt;0;c--) mult++;
<span class="lineNum">     919 </span>            :           node_to_pick=(*mult);
<span class="lineNum">     920 </span>            :         }
<span class="lineNum">     921 </span>            :         //find the node
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :         std::list&lt;node&gt;::iterator best_node=best_nodes.begin();</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         for(int c=node_to_pick;c&gt;0;c--){</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :           best_node++;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :           if(best_node==best_nodes.end()){</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :             WARNING(&quot;multiplicity scanning scheme is garbled!!&quot;);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :             best_node--;</span>
<span class="lineNum">     928 </span>            :           }
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         max_n=*best_node;</span>
<span class="lineNum">     931 </span>            :         
<span class="lineNum">     932 </span>            :         //// do we need to step?
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         if(mls==multiplicity_index+1){</span>
<span class="lineNum">     934 </span>            :           //we have to step iteration over this multiplicity
<span class="lineNum">     935 </span>            :           left_multiplicities_list_t::reverse_iterator tail=
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :             multiplicities_left.rbegin();</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :           (*tail)--;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :           std::cout &lt;&lt; &quot;mult &quot; &lt;&lt; multiplicity_index </span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :                     &lt;&lt; &quot; step &quot; &lt;&lt; *tail </span>
<span class="lineNum">     940 </span>            :                     &lt;&lt; std::endl;
<span class="lineNum">     941 </span>            :         }
<span class="lineNum">     942 </span>            :         multiplicity_index++;
<span class="lineNum">     943 </span>            :       }
<span class="lineNum">     944 </span>            :       
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :     
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :       edge e;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :       if(in_degree(max_n,G) &gt;= out_degree(max_n,G)){</span>
<span class="lineNum">     949 </span>            :         // since we manipulate the edge list, this is a bit tricky:
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         while(in_degree(max_n,G)){</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :           e=*(in_edges(max_n,G).first);</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :           NODE_REPORT(max_n,G);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :           collect_and_fix_tables(e,G,ASG,table2,sum);</span>
<span class="lineNum">     954 </span>            :         }
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         while(out_degree(max_n,G)){</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :           e=*(out_edges(max_n,G).first);</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :           NODE_REPORT(max_n,G);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :           drop_and_fix_tables(e,G,table2,sum);</span>
<span class="lineNum">     959 </span>            :         }
<span class="lineNum">     960 </span>            :       }else{
<span class="lineNum">     961 </span>            :         // since we manipulate the edge list, this is a bit tricky:
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         while(out_degree(max_n,G)){</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :           e=*(out_edges(max_n,G).first);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :           NODE_REPORT(max_n,G);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :           collect_and_fix_tables(e,G,ASG,table2,sum);</span>
<span class="lineNum">     966 </span>            :         }
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         while(in_degree(max_n,G)){</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :           e=*(in_edges(max_n,G).first);</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :           NODE_REPORT(max_n,G);</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :           drop_and_fix_tables(e,G,table2,sum);</span>
<span class="lineNum">     971 </span>            :         }
<span class="lineNum">     972 </span>            :       }
<span class="lineNum">     973 </span>            :       ASSERT(in_degree(max_n,G)==0);
<span class="lineNum">     974 </span>            :       ASSERT(out_degree(max_n,G)==0);
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            :       //remove_vertex(max_n,G);
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :       vertex_alife[max_n]=false;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       vertices_alife--;</span>
<span class="lineNum">     979 </span>            :     }// while(vertices_alife)
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     unsigned int h=graph_hash(ASG);</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :     if(hashs_of_graphs_found_so_far.find(h)!=</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :        hashs_of_graphs_found_so_far.end() ){</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       std::cout &lt;&lt; &quot;multiplicity, but not new result&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">     985 </span>            :     }else{
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :       std::vector&lt;int&gt;  ord(num_vertices(ASG)); // use later</span>
<span class="lineNum">     987 </span>            :       // we refrain from checking if graphs are equal when hashs are equal.
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :       hashs_of_graphs_found_so_far.insert(h);</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            :       // ASG is now an approximately maximal acyclic subgraph of the
<span class="lineNum">     991 </span>            :       // food web still excluding two-loops
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :       topological_sort(ASG,ord.rbegin());</span>
<span class="lineNum">     994 </span>            : //       ASG.sort_nodes(ord);
<span class="lineNum">     995 </span>            : //       ASG.print();
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            :       // get the ordering so far determined:
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :       follows_t follows=transitive_closure(ASG);</span>
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            :       // insert decided two-loops and list undecied two-loops:
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :       mini_loop_list_t undecied_two_loops;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :       for(mini_loop_list_t::iterator l=mini_loops.begin();</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :           l!=mini_loops.end();</span>
<span class="lineNum">    1004 </span>            :           l++  ){
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         if(l-&gt;first != l-&gt;second){ // only two-loops</span>
<span class="lineNum">    1006 </span>            : //        std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; ASG.inf(l-&gt;first) &lt;&lt; &quot;,&quot; 
<span class="lineNum">    1007 </span>            : //                  &lt;&lt; ASG.inf(l-&gt;second) &lt;&lt; &quot;&gt; &quot; ;
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :           if(ord[l-&gt;second]&lt;ord[l-&gt;first]){</span>
<span class="lineNum">    1009 </span>            :             // reorder:
<span class="lineNum">    1010 </span>            : //          std::cout &lt;&lt; &quot;reordered to &quot;;
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :             *l=std::pair&lt;node,node&gt;(l-&gt;second,l-&gt;first);</span>
<span class="lineNum">    1012 </span>            : //          std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; ASG.inf(l-&gt;first) &lt;&lt; &quot;,&quot; 
<span class="lineNum">    1013 </span>            : //                    &lt;&lt; ASG.inf(l-&gt;second) &lt;&lt; &quot;&gt; &quot; ;
<span class="lineNum">    1014 </span>            :           }
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :           if(boost::edge(l-&gt;first,l-&gt;second,follows).second){</span>
<span class="lineNum">    1016 </span>            :             // the two-loop is decided, insert it
<span class="lineNum">    1017 </span>            : //          std::cout &lt;&lt; &quot;inserted&quot; ;
<span class="lineNum">    1018 </span>            : //            ASG.new_edge(l-&gt;first,l-&gt;second);
<span class="lineNum">    1019 </span>            :           }else{
<span class="lineNum">    1020 </span>            : //          std::cout &lt;&lt; &quot;kept&quot; ;
<span class="lineNum">    1021 </span>            :             // the two-loop is undecided:
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :             undecied_two_loops.push_back(*l);</span>
<span class="lineNum">    1023 </span>            :           }
<span class="lineNum">    1024 </span>            : //        std::cout &lt;&lt; std::endl;
<span class="lineNum">    1025 </span>            :         }
<span class="lineNum">    1026 </span>            :       }
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : //       REPORT(TOPSORT(ASG,ord));
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :       // sample undecided two-loop ordering at random?
<span class="lineNum">    1032 </span>            :       int n_undecided=
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :         (go_through_multiplicities ? undecied_two_loops.size() : 0 );</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :       const int randomization_threshold=8;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :       WARN_IF(n_undecided&gt;=randomization_threshold,&quot;randomizing&quot;);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       const bool randomizing=(n_undecided&gt;=randomization_threshold);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :       if(randomizing) ;REPORT(n_undecided);</span>
<span class="lineNum">    1038 </span>            :       
<span class="lineNum">    1039 </span>            :       //loop over all/many orderings of two-loops:
<span class="lineNum">    1040 </span>            :       typedef long long int orderbits;
<span class="lineNum">    1041 </span>            :       int n_acyclic=0;
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       for(orderbits ordering_index=0;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :           ordering_index &lt; </span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :             (orderbits(1)&lt;&lt;(randomizing?randomization_threshold:n_undecided))</span>
<span class="lineNum">    1045 </span>            :             ;
<span class="lineNum">    1046 </span>            :           ordering_index++){
<span class="lineNum">    1047 </span>            :         orderbits ordering=
<span class="lineNum">    1048 </span>            :           (randomizing?
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :            orderbits(random_double(orderbits(1)&lt;&lt;n_undecided)) :</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :            ordering_index);</span>
<span class="lineNum">    1051 </span>            :         
<span class="lineNum">    1052 </span>            :         //this ordering always goes through, so we have at least one,
<span class="lineNum">    1053 </span>            :         //even when randomizing:
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         if(ordering_index==0) ordering=0;</span>
<span class="lineNum">    1055 </span>            :         
<span class="lineNum">    1056 </span>            :         //insert edges according to ordering:
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         std::list&lt;edge&gt; inserted_twoloop_edges;</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         int position=0;</span>
<span class="lineNum">    1059 </span>            : //      REPORT(ordering);
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         for(mini_loop_list_t::iterator i=</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :               undecied_two_loops.begin();</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :             i!=undecied_two_loops.end();</span>
<span class="lineNum">    1063 </span>            :             i++,position++ ){
<span class="lineNum">    1064 </span>            : //        REPORT(TOPSORT(ASG,ord));
<span class="lineNum">    1065 </span>            : //        ASG.print();
<span class="lineNum">    1066 </span>            : //        std::cout &lt;&lt; position &lt;&lt; &quot;&lt;&quot; &lt;&lt; ASG.inf(i-&gt;first) &lt;&lt; &quot;,&quot; 
<span class="lineNum">    1067 </span>            : //                  &lt;&lt; ASG.inf(i-&gt;second) &lt;&lt; &quot;&gt; inserted &quot; ;
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :           if( (orderbits(1)&lt;&lt;position) &amp; ordering ){</span>
<span class="lineNum">    1069 </span>            : //          std::cout &lt;&lt; &quot;reverse&quot;;
<span class="lineNum">    1070 </span>            :             inserted_twoloop_edges.
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :               push_back(add_edge(i-&gt;second,i-&gt;first,ASG).first);</span>
<span class="lineNum">    1072 </span>            :           }else{
<span class="lineNum">    1073 </span>            :             inserted_twoloop_edges.
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :               push_back(add_edge(i-&gt;first,i-&gt;second,ASG).first);</span>
<span class="lineNum">    1075 </span>            :           }
<span class="lineNum">    1076 </span>            : //        std::cout &lt;&lt; std::endl;
<span class="lineNum">    1077 </span>            : //        REPORT(TOPSORT(ASG,ord));
<span class="lineNum">    1078 </span>            : //        ASG.print();
<span class="lineNum">    1079 </span>            :         }
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :         //check if result is acyclic:
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         bool is_acyclic=true;</span>
<span class="lineNum">    1083 </span>            :         try{
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :           topological_sort(ASG,ord.rbegin());</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         }catch(boost::not_a_dag){</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :           is_acyclic=false;</span>
<span class="lineNum">    1087 </span>            :         }
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         if(is_acyclic){</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :           n_acyclic++;</span>
<span class="lineNum">    1090 </span>            :           // is acyclic. evaluate:
<span class="lineNum">    1091 </span>            :           //      ASG.sort_nodes(ord);
<span class="lineNum">    1092 </span>            :       
<span class="lineNum">    1093 </span>            :           // compute permutation of indices:
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :           permutation p(m.size());</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :           forall(n,vertices(ASG)){</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :             p[ord[n]]=n;</span>
<span class="lineNum">    1097 </span>            :           }
<span class="lineNum">    1098 </span>            :     
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :           Interaction_Matrix nm=m.permute(p);</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :           stats.sorted=nm;</span>
<span class="lineNum">    1101 </span>            : //        nm.Print();
<span class="lineNum">    1102 </span>            : //        FATAL_ERROR(&quot;check_this&quot;);
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :           std::simple_vector&lt;histogram&gt; 
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :             chains_from(num_vertices(ASG),histogram());</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :           histogram h; // chain length distribution</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :           bool found=false;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :           forall(n,vertices(ASG)){</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :             if(out_degree(n,ASG)==0){</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :               found=true;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :               h+=directed_food_chains_from(n,ASG,chains_from);</span>
<span class="lineNum">    1112 </span>            :             }
<span class="lineNum">    1113 </span>            :           };
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :           if(!found){</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :             FATAL_ERROR(&quot;could not find a lowest trophic level&quot;);</span>
<span class="lineNum">    1116 </span>            :           }
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :           weighted_average_meter length;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :           long double sum=0;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :           for(unsigned int i=0;i&lt;h.size();i++){</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :             if(h[i]&lt;0) FATAL_ERROR(&quot;histogram overflow!&quot;);</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :             length.sample(i,h[i]);</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :             sum+=h[i];</span>
<span class="lineNum">    1123 </span>            :           }
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :           oChnLg.sample(length.readout());</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :           if(!finite(length.sample_std())){</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :             std::cout &lt;&lt; h &lt;&lt; std::endl;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :             WARNING(&quot;overflow in average meter??&quot;);</span>
<span class="lineNum">    1128 </span>            :           }
<span class="lineNum">    1129 </span>            :           else
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             oChnSD.sample(length.sample_std());</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :           if(!finite(log10(sum)))</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :             WARNING(&quot;overflow computing sum??&quot;);</span>
<span class="lineNum">    1133 </span>            :           else
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :             oChnNo.sample(log10(sum));</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :           oLoop.sample(loop_count(nm));</span>
<span class="lineNum">    1136 </span>            :       
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :           average_meter std;</span>
<span class="lineNum">    1138 </span>            :           std::simple_vector&lt;histogram&gt; 
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :             chains_to(num_vertices(ASG),histogram());</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :           forall(n,vertices(ASG)){</span>
<span class="lineNum">    1141 </span>            :             histogram h=
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :               directed_food_chains_to(n,ASG,chains_to);</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :             weighted_average_meter l;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :             for(unsigned int i=0;i&lt;h.size();i++){</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :               l.sample(i,h[i]);</span>
<span class="lineNum">    1146 </span>            :             }
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :             double lstd=l.sample_std();</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :             if(my_isnan(lstd) || my_isinf(lstd))</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :               WARNING(&quot;disconnected node encountered when computing oOmniv&quot;);</span>
<span class="lineNum">    1150 </span>            :             else
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :               std.sample(lstd);</span>
<span class="lineNum">    1152 </span>            :           }
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :           double stdm=std.readout();</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :           if(my_isnan(stdm) || my_isinf(stdm))</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :             FATAL_ERROR(&quot;could not compute oOmniv&quot;);</span>
<span class="lineNum">    1156 </span>            :           else
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :             oOmniv.sample(stdm);</span>
<span class="lineNum">    1158 </span>            :         } // if(TOPSORT(ASG))
<span class="lineNum">    1159 </span>            :         
<span class="lineNum">    1160 </span>            :         //remove undecided two-loop branches:
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :         for(std::list&lt;edge&gt;::iterator i=</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :               inserted_twoloop_edges.begin();</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :             i!=inserted_twoloop_edges.end();</span>
<span class="lineNum">    1164 </span>            :             i++){
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :           remove_edge(*i,ASG);</span>
<span class="lineNum">    1166 </span>            :         }
<span class="lineNum">    1167 </span>            :       } // loop over orderings of two-loops
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :       if(n_acyclic &gt; 1){</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         std::cout &lt;&lt; n_acyclic &lt;&lt; &quot; graphs of &quot; &lt;&lt; </span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :           (orderbits(1)&lt;&lt;(randomizing?randomization_threshold:n_undecided))</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :                   &lt;&lt; &quot; acyclic &quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    1172 </span>            :       }
<span class="lineNum">    1173 </span>            :     }// condition that graph is unique so far
<span class="lineNum">    1174 </span>            :     
<span class="lineNum">    1175 </span>            :     // drop finished multiplicities...
<span class="lineNum">    1176 </span>            :     //ASSERT(multiplicities_left.size()==multiplicity_index);
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     if(multiplicities_left.size()!=multiplicity_index){</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :       WARN_IF(multiplicities_left.size()!=multiplicity_index,</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :               &quot;HIT THIS BUG AGAIN!&quot;);</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :       REPORT(multiplicities_left.size());</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :       REPORT(multiplicity_index);</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :       std::cout &lt;&lt; &quot;multiplicities_left:&quot;;</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :       while(!multiplicities_left.empty()){</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :         std::cout &lt;&lt; *multiplicities_left.begin() &lt;&lt; &quot; &quot; ;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         multiplicities_left.pop_front();</span>
<span class="lineNum">    1186 </span>            :       }
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :       std::cout &lt;&lt; std::endl;</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1189 </span>            :     }
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     while(!multiplicities_left.empty() &amp;&amp;</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :           *(multiplicities_left.rbegin())&lt;=0) </span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :       multiplicities_left.pop_back();</span>
<span class="lineNum">    1193 </span>            :     // ... and continue if some are left
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :   }while(!multiplicities_left.empty());</span>
<span class="lineNum">    1195 </span>            :   
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :   stats.oChnLg=oChnLg.readout();</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :   stats.oChnSD=oChnSD.readout();</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   stats.oChnNo=oChnNo.readout();</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   stats.oLoop=oLoop.readout();</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :   stats.oOmniv=oOmniv.readout();</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   return stats;</span>
<span class="lineNum">    1203 </span>            : }
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 : void find_lowest_level(Interaction_Matrix &amp; m,std::simple_vector&lt;bool&gt; &amp; lowest){</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   FATAL_ERROR(&quot;find_lowest_level works only with debugging options set!&quot;);</span>
<span class="lineNum">    1207 </span>            :   //(LEDA bug??)
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   Graph G(m.size()); </span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">    1213 </span>            :     }
<span class="lineNum">    1214 </span>            :   }
<span class="lineNum">    1215 </span>            :   
<span class="lineNum">    1216 </span>            :   // compute strongly connected components:
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   boost::vector_property_map&lt;int&gt; compnum(num_vertices(G));</span>
<span class="lineNum">    1218 </span>            :   int number_of_components=
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     strong_components(G, compnum);</span>
<span class="lineNum">    1220 </span>            :   
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;bool&gt; lowestcomp(num_vertices(G),true);</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   forall(e,edges(G)){</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     if(compnum[source(e,G)]!=compnum[target(e,G)]){</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :       lowestcomp[source(e,G)]=false;</span>
<span class="lineNum">    1226 </span>            :     }
<span class="lineNum">    1227 </span>            :   }
<span class="lineNum">    1228 </span>            :   
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     REPORT(i);</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     REPORT(lowestcomp[i]);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :     lowest[i]=lowestcomp[i];</span>
<span class="lineNum">    1233 </span>            :   }
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">    1235 </span>            : }
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : distribution trophic_height_vector(const Interaction_Matrix &amp; m){</span>
<span class="lineNum">    1238 </span>            :   //!!! we assume G to be acyclic!!
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :   Graph G(m.size()); </span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;m.size();j++){</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :       if((int)m[i][j]==(int)NetworkAnalysis::eats)</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :         add_edge(i,j,G);</span>
<span class="lineNum">    1245 </span>            :     }
<span class="lineNum">    1246 </span>            :   }
<span class="lineNum">    1247 </span>            :   
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :   distribution heights(m.size());</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">    1250 </span>            :     std::simple_vector&lt;histogram&gt; 
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :       chains_to(num_vertices(G),histogram());</span>
<span class="lineNum">    1252 </span>            :     histogram h=
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :       directed_food_chains_to(i,G,chains_to);</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :     double lsum=0,nsum=0;</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :     for(int j=h.size();j--&gt;0;){</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :       lsum+=j*h[j];</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :       nsum+=h[j];</span>
<span class="lineNum">    1258 </span>            :     }
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     heights[i]=lsum/nsum+1;</span>
<span class="lineNum">    1260 </span>            :   }
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   return heights;</span>
<span class="lineNum">    1262 </span>            : }
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 : int Cy4(const Interaction_Matrix &amp; m){</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :   Graph G(m.size());  // niche overlap graph</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;node&gt;  ind(m.size());</span>
<span class="lineNum">    1267 </span>            :   //CMatrix&lt;bool&gt; adjacent(m.size(),m.size());
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   Interaction_Matrix adjacent(m.size());</span>
<span class="lineNum">    1269 </span>            :   
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :     for(int j=i+1;j&lt;m.size();j++){</span>
<span class="lineNum">    1272 </span>            :       int k=m.size();
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :       while(k--){</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :         if((int)m[i][k]==(int)NetworkAnalysis::eats &amp;&amp;</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :            (int)m[j][k]==(int)NetworkAnalysis::eats ){</span>
<span class="lineNum">    1276 </span>            :           // niche overlap detected;
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :           add_edge(i,j,G);        </span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :           adjacent[i][j]=NetworkAnalysis::eats;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :           adjacent[j][i]=NetworkAnalysis::eats;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1281 </span>            :         }
<span class="lineNum">    1282 </span>            :       }
<span class="lineNum">    1283 </span>            :     }
<span class="lineNum">    1284 </span>            :   }
<span class="lineNum">    1285 </span>            :   // niche overlap graph constructed
<span class="lineNum">    1286 </span>            :   
<span class="lineNum">    1287 </span>            : //   cout &lt;&lt; &quot;DEBUG:&quot; &lt;&lt; std::endl;
<span class="lineNum">    1288 </span>            : //   m.Print();
<span class="lineNum">    1289 </span>            : //   adjacent.Print();
<span class="lineNum">    1290 </span>            :   
<span class="lineNum">    1291 </span>            :   // Chordless 4-cycles are only counted if:
<span class="lineNum">    1292 </span>            :   // 
<span class="lineNum">    1293 </span>            :   // 1. n1 has the smallest index
<span class="lineNum">    1294 </span>            :   // 2. the index of n2 is smaller than the index of n3
<span class="lineNum">    1295 </span>            :   //
<span class="lineNum">    1296 </span>            :   // This should be sufficient to avoid double counting.
<span class="lineNum">    1297 </span>            :   
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">    1299 </span>            :   node n1,n2,n3,n4;
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   edge e2,e3,e4;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :   forall(n1,vertices(G)){</span>
<span class="lineNum">    1302 </span>            :     // try n1 as starting point of chordless cycle
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     forall(e2,out_edges(n1,G)){</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :       n2=target(e2,G);</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :       forall(e3,out_edges(n1,G)){</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         n3=target(e3,G);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :         if(n2&lt;n3 &amp;&amp; !adjacent[n2][n3]){</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :           forall(e4,out_edges(n2,G)){</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :             n4=target(e4,G);</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :             if(n4 &gt; n1</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                &amp;&amp;</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                !adjacent[n1][n4]</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :                &amp;&amp;</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                adjacent[n3][n4] ){</span>
<span class="lineNum">    1315 </span>            : //            cout &lt;&lt; &quot;cycle: &quot; 
<span class="lineNum">    1316 </span>            : //                 &lt;&lt; G.inf(n1) &lt;&lt; &quot; &quot;
<span class="lineNum">    1317 </span>            : //                 &lt;&lt; G.inf(n2) &lt;&lt; &quot; &quot;
<span class="lineNum">    1318 </span>            : //                 &lt;&lt; G.inf(n4) &lt;&lt; &quot; &quot;
<span class="lineNum">    1319 </span>            : //                 &lt;&lt; G.inf(n3) &lt;&lt; std::endl;
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :               count++;</span>
<span class="lineNum">    1321 </span>            :             }
<span class="lineNum">    1322 </span>            :           }
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :           forall(e4,in_edges(n2,G)){</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :             n4=source(e4,G);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :             if(n4 &gt; n1</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :                &amp;&amp;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                (!adjacent[n1][n4])</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                &amp;&amp;</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                adjacent[n3][n4] ){</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :               std::cout &lt;&lt; &quot;&quot;;//inhibit buggy optimizations by g++</span>
<span class="lineNum">    1331 </span>            : //            std::cout &lt;&lt; &quot;cycle: &quot; 
<span class="lineNum">    1332 </span>            : //                 &lt;&lt; G.inf(n1) &lt;&lt; &quot; &quot;
<span class="lineNum">    1333 </span>            : //                 &lt;&lt; G.inf(n2) &lt;&lt; &quot; &quot;
<span class="lineNum">    1334 </span>            : //                 &lt;&lt; G.inf(n4) &lt;&lt; &quot; &quot;
<span class="lineNum">    1335 </span>            : //                 &lt;&lt; G.inf(n3) &lt;&lt; std::endl;
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :               count++;</span>
<span class="lineNum">    1337 </span>            :             }
<span class="lineNum">    1338 </span>            :           }
<span class="lineNum">    1339 </span>            :         }
<span class="lineNum">    1340 </span>            :       }
<span class="lineNum">    1341 </span>            :     }
<span class="lineNum">    1342 </span>            :   }
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   return count;</span>
<span class="lineNum">    1344 </span>            : }
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            : // Lex-BFS:
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            : typedef std::vector&lt;node&gt; list_to_partition;
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            : class set_of_nodes{
<span class="lineNum">    1351 </span>            : public:
<span class="lineNum">    1352 </span>            :   list_to_partition::iterator Begin;
<span class="lineNum">    1353 </span>            :   list_to_partition::iterator End;
<span class="lineNum">    1354 </span>            :   list_to_partition::iterator Begin_Split;
<span class="lineNum">    1355 </span>            :   set_of_nodes(list_to_partition::iterator b,list_to_partition::iterator e):
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     Begin(b),End(e),Begin_Split(e){};</span>
<span class="lineNum">    1357 </span>            : };
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : typedef std::list&lt;set_of_nodes&gt; set_list;
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 : static std::simple_vector&lt;int&gt; Lex_BFS_Ordering(const ugraph &amp; G){</span>
<span class="lineNum">    1363 </span>            :   // implementation of Algorithm 2 of Habib et al. (2000),
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;int&gt; pi(num_vertices(G),-1);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;list_to_partition::iterator&gt; position_of(num_vertices(G));</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;set_list::iterator&gt; set_of(num_vertices(G));</span>
<span class="lineNum">    1367 </span>            :   
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   list_to_partition l(num_vertices(G));</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   set_list L;</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   L.push_back(set_of_nodes(l.begin(),l.end()));</span>
<span class="lineNum">    1371 </span>            : //   REPORT(L.begin()-&gt;Begin_Split-l.begin());
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   std::stack&lt;set_list::iterator&gt; might_need_fixing;</span>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            :   node n;
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   list_to_partition::iterator i=l.begin();</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :   forall(n,vertices(G)){</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     position_of[n]=i;</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :     *i=n;</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :     i++;</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     set_of[n]=L.begin();</span>
<span class="lineNum">    1381 </span>            :   }
<span class="lineNum">    1382 </span>            :   
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :   int index=num_vertices(G);</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   set_list::iterator singletons_start=L.end();</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   while(singletons_start!=L.begin()){</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     set_list::iterator last_non_visited_class=singletons_start;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     last_non_visited_class--;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     last_non_visited_class-&gt;End--;</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     last_non_visited_class-&gt;Begin_Split--;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     node x=*(last_non_visited_class-&gt;End);</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :     if(last_non_visited_class-&gt;End==last_non_visited_class-&gt;Begin){</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :       singletons_start--;</span>
<span class="lineNum">    1393 </span>            :     }
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     pi[x]=--index;</span>
<span class="lineNum">    1395 </span>            :     node y;
<span class="lineNum">    1396 </span>            : //     REPORT((position_of[x]-l.begin()));
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     forall(y,adjacent_vertices(x,G)){</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :       if(position_of[y]&lt;position_of[x]){</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         set_list::iterator chi_b=set_of[y];</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         might_need_fixing.push(chi_b);</span>
<span class="lineNum">    1401 </span>            : //      REPORT((chi_b-&gt;Begin-l.begin()));
<span class="lineNum">    1402 </span>            : //      REPORT((chi_b-&gt;Begin_Split-l.begin()));
<span class="lineNum">    1403 </span>            : //      REPORT((position_of[y]-l.begin()));
<span class="lineNum">    1404 </span>            : //      ASSERT(position_of[y]&gt;=chi_b-&gt;Begin);
<span class="lineNum">    1405 </span>            : //      ASSERT(position_of[y]&lt;chi_b-&gt;End);
<span class="lineNum">    1406 </span>            : //      ASSERT(position_of[y]&lt;chi_b-&gt;Begin_Split);
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :         --(chi_b-&gt;Begin_Split);</span>
<span class="lineNum">    1408 </span>            : //      REPORT((chi_b-&gt;Begin_Split-l.begin()));
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :         position_of[*(chi_b-&gt;Begin_Split)]=position_of[y];</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :         iter_swap(position_of[y],chi_b-&gt;Begin_Split);</span>
<span class="lineNum">    1411 </span>            :         // fix position_of:
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :         position_of[y]=(chi_b-&gt;Begin_Split);</span>
<span class="lineNum">    1413 </span>            : #if xDEBUGGING
<span class="lineNum">    1414 </span>            :         node z;
<span class="lineNum">    1415 </span>            :         forall_nodes(z,G){
<span class="lineNum">    1416 </span>            :         std::cout &lt;&lt; position_of[z]-l.begin() &lt;&lt; &quot; &quot;;
<span class="lineNum">    1417 </span>            :         }
<span class="lineNum">    1418 </span>            :         std::cout &lt;&lt; std::endl;
<span class="lineNum">    1419 </span>            : #endif 
<span class="lineNum">    1420 </span>            :       }
<span class="lineNum">    1421 </span>            :     }
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :     while(!might_need_fixing.empty()){</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :       set_list::iterator &amp; chi_b=might_need_fixing.top();</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :       if(chi_b-&gt;Begin_Split!=chi_b-&gt;End){</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :         if(chi_b-&gt;Begin_Split==chi_b-&gt;Begin){</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :           chi_b-&gt;Begin_Split=chi_b-&gt;End;</span>
<span class="lineNum">    1428 </span>            :         }else{
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :           set_list::iterator chi_new=chi_b;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :           chi_new++;</span>
<span class="lineNum">    1431 </span>            : #if DEBUGGING
<span class="lineNum">    1432 </span>            :           set_list::iterator chi_new_hold=chi_new;
<span class="lineNum">    1433 </span>            : #endif
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :           chi_new=L.insert(chi_new,set_of_nodes(chi_b-&gt;Begin_Split,chi_b-&gt;End));</span>
<span class="lineNum">    1435 </span>            :           ASSERT(chi_new_hold!=chi_new);
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :           chi_b-&gt;End=chi_b-&gt;Begin_Split;</span>
<span class="lineNum">    1437 </span>            :           // fix set_of:
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :           for(list_to_partition::iterator y=chi_new-&gt;Begin;</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :               y!=chi_new-&gt;End;</span>
<span class="lineNum">    1440 </span>            :               y++){
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :             set_of[*y]=chi_new;</span>
<span class="lineNum">    1442 </span>            :           }
<span class="lineNum">    1443 </span>            :         }
<span class="lineNum">    1444 </span>            :       }
<span class="lineNum">    1445 </span>            :       might_need_fixing.pop();
<span class="lineNum">    1446 </span>            :     }
<span class="lineNum">    1447 </span>            :   }
<span class="lineNum">    1448 </span>            :   ASSERT(index==0);
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :   return pi;</span>
<span class="lineNum">    1450 </span>            : }
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : // helper for is_chordal below
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            : static bool 
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 : is_chordal_check_order(const std::vector&lt; std::list &lt;int&gt; &gt; &amp; children_of,</span>
<span class="lineNum">    1456 </span>            :                        const std::vector&lt; int &gt; &amp; parent,
<span class="lineNum">    1457 </span>            :                        const std::vector&lt; std::list &lt;int&gt; &gt; &amp; RN,
<span class="lineNum">    1458 </span>            :                        int x ,
<span class="lineNum">    1459 </span>            :                        int &amp;n_cliques,
<span class="lineNum">    1460 </span>            :                        std::vector&lt; bool &gt; &amp; makes_maxial_clique
<span class="lineNum">    1461 </span>            :                        ){
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   if(x&lt;parent.size()){</span>
<span class="lineNum">    1463 </span>            :   
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     std::list&lt;int&gt;::const_iterator j=RN[parent[x]].begin();</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     const std::list&lt;int&gt;::const_iterator end_j=RN[parent[x]].end();</span>
<span class="lineNum">    1466 </span>            :     // for all right neighbours *i of x, excluding its parent...
<span class="lineNum">    1467 </span>            :     
<span class="lineNum">    1468 </span>            : //     REPORT(x);
<span class="lineNum">    1469 </span>            : //     REPORT(*(RN[x].begin()));
<span class="lineNum">    1470 </span>            :     
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     bool sets_identical=true;</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     for(std::list&lt;int&gt;::const_iterator i=++(RN[x].begin());</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :         i!=RN[x].end();</span>
<span class="lineNum">    1474 </span>            :         i++){
<span class="lineNum">    1475 </span>            :       
<span class="lineNum">    1476 </span>            : //       REPORT(*i);
<span class="lineNum">    1477 </span>            :       // Here is the Algorithm 3 part:
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :       if(j==end_j) return false;</span>
<span class="lineNum">    1479 </span>            :       // ... search for *i in RN[parent[x]]:
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :       while(*i!=*(j++)){</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :         if(j==end_j){</span>
<span class="lineNum">    1482 </span>            :           // not found!
<span class="lineNum">    1483 </span>            :           return false;
<span class="lineNum">    1484 </span>            :         }else{
<span class="lineNum">    1485 </span>            :           sets_identical=false;
<span class="lineNum">    1486 </span>            :         }
<span class="lineNum">    1487 </span>            :       }
<span class="lineNum">    1488 </span>            :     }
<span class="lineNum">    1489 </span>            :       
<span class="lineNum">    1490 </span>            :     // Here is the Algorithm 4 part:
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     if(sets_identical){</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :       if(parent[x]==parent.size()){</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         n_cliques++;</span>
<span class="lineNum">    1494 </span>            :       }else{
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         if(makes_maxial_clique[parent[x]]){</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :           makes_maxial_clique[parent[x]]=false;</span>
<span class="lineNum">    1497 </span>            :         }else{
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :           n_cliques++;</span>
<span class="lineNum">    1499 </span>            :         }
<span class="lineNum">    1500 </span>            :       }
<span class="lineNum">    1501 </span>            :     }else{
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :       n_cliques++;</span>
<span class="lineNum">    1503 </span>            :     }
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     makes_maxial_clique[x]=true;</span>
<span class="lineNum">    1505 </span>            :   }
<span class="lineNum">    1506 </span>            :   
<span class="lineNum">    1507 </span>            :   // the recursion:
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   for(std::list&lt; int &gt;::const_iterator i=children_of[x].begin();</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :       i!=children_of[x].end();</span>
<span class="lineNum">    1510 </span>            :       i++){
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :     if(!is_chordal_check_order(children_of,parent,RN,*i,</span>
<span class="lineNum">    1512 </span>            :                                n_cliques,makes_maxial_clique ))
<span class="lineNum">    1513 </span>            :       return false;
<span class="lineNum">    1514 </span>            :   }
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            :   return true;
<span class="lineNum">    1517 </span>            : }
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span>            : // these three types are used for by Algorithm 9:
<span class="lineNum">    1521 </span>            : typedef std::vector&lt;int&gt; cliques_to_partition;
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span>            : class set_of_cliques{
<span class="lineNum">    1524 </span>            : public:
<span class="lineNum">    1525 </span>            :   cliques_to_partition::iterator Begin;
<span class="lineNum">    1526 </span>            :   cliques_to_partition::iterator End;
<span class="lineNum">    1527 </span>            :   cliques_to_partition::iterator Begin_Split;
<span class="lineNum">    1528 </span>            :   set_of_cliques(cliques_to_partition::iterator b,
<span class="lineNum">    1529 </span>            :                  cliques_to_partition::iterator e):
<span class="lineNum">    1530 </span>            :     Begin(b),End(e),Begin_Split(e){};
<span class="lineNum">    1531 </span>            : };
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            : typedef std::list&lt;set_of_cliques&gt; clique_set_list;
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 : static int is_chordal(const ugraph &amp; G,const std::simple_vector&lt;int&gt; &amp; index){</span>
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span>            :   // implementation of Algorithms 3, 4, and 9 of Habib et al. (2000):
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   const int S=num_vertices(G);</span>
<span class="lineNum">    1541 </span>            :   node x,y;
<span class="lineNum">    1542 </span>            :   
<span class="lineNum">    1543 </span>            :   // generate and sort right neighbour (RN) sets:
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   std::vector&lt; std::stack&lt; int &gt; &gt; arn(S);</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :   forall(x,vertices(G)){</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     forall(y,adjacent_vertices(x,G)){</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :       if(index[y] &gt; index[x]){</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :         arn[index[y]].push(index[x]);</span>
<span class="lineNum">    1549 </span>            :       }
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span>            :   }
<span class="lineNum">    1552 </span>            :   
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   std::vector&lt; std::list&lt; int &gt; &gt; RN(S+1);</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;S;i++){</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     std::stack&lt;int&gt; &amp; s=arn[i];</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :     while(!s.empty()){</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :       RN[s.top()].push_back(i);</span>
<span class="lineNum">    1558 </span>            :       s.pop();
<span class="lineNum">    1559 </span>            :     }
<span class="lineNum">    1560 </span>            :   }
<span class="lineNum">    1561 </span>            :   
<span class="lineNum">    1562 </span>            :   // generate tree structure:
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   std::vector&lt; std::list &lt;int&gt; &gt; children_of(S+1);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   std::vector&lt; int &gt; parent(S);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;S;i++){</span>
<span class="lineNum">    1566 </span>            :     // make sure every node has a right neighbour:
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :     RN[i].push_back(S);</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :     parent[i]=RN[i].front();</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     children_of[parent[i]].push_back(i);</span>
<span class="lineNum">    1570 </span>            :   }
<span class="lineNum">    1571 </span>            :   
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   std::vector&lt; bool &gt; makes_maxial_clique(S,false);</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :   int n_cliques=0;</span>
<span class="lineNum">    1574 </span>            :   
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   if(!is_chordal_check_order(children_of,parent,RN,S,</span>
<span class="lineNum">    1576 </span>            :                              n_cliques,makes_maxial_clique)){
<span class="lineNum">    1577 </span>            :     return 0;
<span class="lineNum">    1578 </span>            :   }
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   CMatrix&lt;NetworkAnalysis::Interaction&gt; cm(S,n_cliques);</span>
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span>            : //   REPORT(n_cliques);
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   int c=0;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   for(int i=S;i--&gt;0;){</span>
<span class="lineNum">    1586 </span>            : //     REPORT(i);
<span class="lineNum">    1587 </span>            : //     REPORT(makes_maxial_clique[i]);
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :     if(makes_maxial_clique[i]){</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :       for(std::list&lt;int&gt;::iterator m=RN[i].begin();</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :           m!=RN[i].end();</span>
<span class="lineNum">    1591 </span>            :           m++){
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :         if(*m!=S){</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :           cm[*m][c]=NetworkAnalysis::eats;</span>
<span class="lineNum">    1594 </span>            :         }
<span class="lineNum">    1595 </span>            :       }
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :       cm[i][c]=NetworkAnalysis::eats;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :       c++;</span>
<span class="lineNum">    1598 </span>            :       ASSERT(c&lt;=n_cliques);
<span class="lineNum">    1599 </span>            :     }
<span class="lineNum">    1600 </span>            :   }
<span class="lineNum">    1601 </span>            :   
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :   std::cout  &lt;&lt; &quot;CLIQUES START&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   for(int j=0;j&lt;n_cliques;j++){</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :     for(int i=0;i&lt;S;i++){</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :       std::cout &lt;&lt; (cm[i][j]==NetworkAnalysis::eats ? &quot;X&quot; : &quot; &quot;);</span>
<span class="lineNum">    1606 </span>            :     }
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :     std::cout &lt;&lt; std::endl;</span>
<span class="lineNum">    1608 </span>            :   }
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :   std::cout  &lt;&lt; &quot;CLIQUES END&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    1610 </span>            :   
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :   if(has_consecutive_ones(cm))</span>
<span class="lineNum">    1612 </span>            :     return 2;
<span class="lineNum">    1613 </span>            :   else
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1615 </span>            :   
<span class="lineNum">    1616 </span>            : //   // Here starts the Algorithm 9 part:
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span>            : //   cliques_to_partition l(n_cliques);
<span class="lineNum">    1619 </span>            : //   clique_set_list L;
<span class="lineNum">    1620 </span>            : //   L.push_back(set_of_cliques(l.begin(),l.end()));
<span class="lineNum">    1621 </span>            : //   std::stack&lt;clique_set_list::iterator&gt; might_need_fixing;
<span class="lineNum">    1622 </span>            : //   set_list::iterator singletons_start=L.end();
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            : //   std::stack&lt; int &gt; pivots;
<span class="lineNum">    1625 </span>            : //   std::vector&lt; bool &gt; pivot_processed(n_cliques,false);
<span class="lineNum">    1626 </span>            :   
<span class="lineNum">    1627 </span>            : //   while(true){
<span class="lineNum">    1628 </span>            : //     set_list::iterator chi_c=singletons_start;
<span class="lineNum">    1629 </span>            : //     chi_c--;
<span class="lineNum">    1630 </span>            : //     while(chi_c is singleton &amp;&amp; chi_c!=L.begin()){
<span class="lineNum">    1631 </span>            : //       singletons_start=chi_c--;
<span class="lineNum">    1632 </span>            : //     }
<span class="lineNum">    1633 </span>            : //     if(chi_c is singleton)
<span class="lineNum">    1634 </span>            : //       break;
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            : //     if(pivots.empty()){
<span class="lineNum">    1637 </span>            : //       cliques_to_partition::iterator last_clique=chi_c.Begin;
<span class="lineNum">    1638 </span>            : //       for(cliques_to_partition::iterator c=
<span class="lineNum">    1639 </span>            : //          chi_c.Begin;
<span class="lineNum">    1640 </span>            : //        c!=chi_c.End;
<span class="lineNum">    1641 </span>            : //        chi_c++){
<span class="lineNum">    1642 </span>            : //      if(*c&gt;*last_clique){
<span class="lineNum">    1643 </span>            : //        last_clique=c;
<span class="lineNum">    1644 </span>            : //      }
<span class="lineNum">    1645 </span>            : //       }
<span class="lineNum">    1646 </span>            :       
<span class="lineNum">    1647 </span>            : //       ... separate c as a new partition ...;
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            : //     }else{
<span class="lineNum">    1650 </span>            : //       while(pivot_processed[pivots.top()]){
<span class="lineNum">    1651 </span>            : //      pivots.pop();
<span class="lineNum">    1652 </span>            : //       }
<span class="lineNum">    1653 </span>            : //       int x=pivots.top()
<span class="lineNum">    1654 </span>            : //       pivot_processed[pivots.top()]=true;
<span class="lineNum">    1655 </span>            : //       pivots.pop();
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            : }
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 : int niche_overlap_graph_analysis(const Interaction_Matrix &amp; m){</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :   ugraph G; </span>
<span class="lineNum">    1661 </span>            :   
<span class="lineNum">    1662 </span>            :   // find niche overlap graph:
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   for(int i=0;i&lt;m.size();i++){</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :     for(int j=0;j&lt;i;j++){</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :       for(int k=0;k&lt;m.size();k++){</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :         if(m.eats(i,k) &amp;&amp; m.eats(j,k)){</span>
<span class="lineNum">    1667 </span>            :           // there is niche overlap:
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :           add_edge(i,j,G);</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1670 </span>            :         }
<span class="lineNum">    1671 </span>            :       }
<span class="lineNum">    1672 </span>            :     }
<span class="lineNum">    1673 </span>            :   }
<span class="lineNum">    1674 </span>            :   
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :   std::simple_vector&lt;int&gt; index=Lex_BFS_Ordering(num_vertices(G));</span>
<a name="1676"><span class="lineNum">    1676 </span>            : </a>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :   return is_chordal(G,index);</span>
<span class="lineNum">    1678 </span><span class="lineCov">        135 : }</span>
<span class="lineNum">    1679 </span>            :   
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            : #undef forall_set_elements
<span class="lineNum">    1683 </span>            :  
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
