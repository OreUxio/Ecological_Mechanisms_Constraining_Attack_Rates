library(plyr)
library(quantreg)
library(Rfast)
library(plyr)
# args = c(0.1,0.3,0.5,0.7,0.9)#commandArgs(trailingOnly=TRUE)
# args<-0.5
args = c(0.9)
###################
### Functions #####
###################

parColMax <- function(M){
  colMaxs(M,value=T,parallel=T)
}

parColWhichMax <- function(M){
  colMaxs(M,value=F)
}

parColWhichMins <- function(M){
  colMins(M,value=F)
}

pickRows <- function(M,indices){
  M[matrix(c(indices,seq(length(indices))),ncol=2)]
}

parColSums <- function(M){
  colsums(M,parallel=T)
}

parColWhichMax <- function(M){
  colMaxs(M,value=F)
}

outcompetition <- function(HH){
  mainResource <- parColWhichMax(HH)
  indirectly <-  t( HH[mainResource,] > pickRows(HH,mainResource) )
  deadd<-colSums(indirectly)>0
  if(any(deadd)){
    victim<-which(deadd)
    assassin<-llply(victim,function(x) which(indirectly[,x]==1))
    victim<-llply(1:length(victim),
                  function(x) victim[x]*(!(mainResource[victim[x]] %in% mainResource[unlist(assassin[x])])))
  }
  indirectly<-rep(F,dim(HH)[2])
  if(any(deadd)){indirectly[unlist(victim)]<-T}
  return(indirectly)
}

sample_and_ser_ext<-function(agg){
  repeat{
    links<-matrix(exp(rnorm(numb_sr,0,sigma))*agg,nrow=1)*alpha_0
    if(sum(links)>1) break
  }
  links<- serial_extinction_t(links)
  return(links)
}

sample_links<-function(agg){
  repeat{
    links<-matrix(exp(rnorm(numb_sr,0,sigma))*agg,nrow=1)*alpha_0
    if(sum(links)>1) break
  }
  return(links)
}

serial_extinction_t<-function(Hi){
  # Simulates the serial extinction process at equilibrium
  repeat{
    sum_Hi <- sum(Hi)
    sum_H2i <- sum(Hi^2)
    max_Hi <- max(Hi)
    out<-Hi
    if(sum_H2i >=  max_Hi*(sum_Hi-1)) break
    deadd<-which.max(Hi)
    Hi <- Hi[-deadd]
  }
  return(out)
}

###################
### Parameters ####
###################

a1<-(0.8^0.5)*1 #as.numeric(args[2])
a2 <- (1.3^0.5)*1
sigma<-4
epsilon<-0.1
resp<-0.1
growth<-0.1
K<-1
inv<-10^-6
rlx_t2<-2000
alpha_0<-epsilon*K/resp
amount_def<-0
amount_inc<-0.05
numb_sr_og<-400
numb_comps_og<-300
agg_all<-10^seq(-4.5,-4.5,length.out = 500)
#####################################
## Type I Exploitative competition #
#####################################
for (ll in 1:length(args)){
  
  # Number of replicates per aggressiveness value
  amount_list_1_diff<-c()
  # Number of resources and consumers
  num_comps<-round(as.numeric(args[ll])*numb_comps_og)
  
  # Generate list of links that can overcome respiration per aggressiveness values:

  for (j in 1:length(agg_all)){
    cat(j/length(agg_all)*100,"%","\r")
    numb_sr<-numb_sr_og
    # Replicate test value
    repeat{
      numb_sr<-numb_sr_og
      # Build interaction matrix with C1 (focal), C2 (first competitor) and resources
      {
        # Sample C1 (focal) and C2 (first competitor)
        repeat{
          numb_sr<-numb_sr_og
          agg_1<-sample(agg_all,1) # Sample C1 (focal)
          C1 <- sample_and_ser_ext(agg_1) # Serial extinction of C1
          C1_temp<-C1
          C1_max<-which.max(C1_temp) # Idenitfy maximal link
          agg_2<-sample(agg_all,1) # Sample C2 (competitor)
          C2 <- sample_and_ser_ext(agg_2)  # Serial extinction of C2
          if(length(C2)<length(C1_temp)){ # Check that C1 and C2 have the same number of links, remove links until they do
            C1_temp<-C1_temp[-sample((1:length(C1_temp))[-C1_max],length(C1_temp)-length(C2))]
          } else if (length(C2)>length(C1_temp)){
            C2<-C2[-sample((1:length(C2))[-which.max(C2)],length(C2)-length(C1_temp))]
          }
          
          C1_max<-which.max(C1_temp) 
          t_HH<-sum(C1_temp*C2) 
          HH<-matrix(C1_temp,ncol=1);HH<-cbind(HH,matrix(C2,ncol=1)) # Create community matrix of C1, C2 and shared R's
          
          # Ensure that a) trophic links > 3, b) C1 and C2 do not share a common maximal resource, 
          # c) C1 is not outcompeted due to phyrric comp d) C1 is not outcompeted due to exploitative comp
          # e) both C1 and C2 can overcome respiration 
          # f) C2 does not need to commit serial extinction again
          if (length(C2)>=3 &
              which.max(C2) != C1_max & 
              # !any(outcompetition(HH)) &
              ( ((sum(C1_temp)-1)/t_HH) / ( (sum(C2)-1)/sum(C2^2) ) < 1) &
              sum(C1_temp)>1 & sum(C2)>1 &
              length(serial_extinction_t(C2))==length(C2) ){break}
        }
        
        # Construct interaction matrix
        C1<-C1_temp
        numb_sr<-length(C1)
        C_matrix<-matrix(rep(0,(numb_sr+1)^2),ncol=numb_sr+1)
        C_matrix[1,]<-c(0,epsilon*C1/alpha_0)
        for (i in 1:numb_sr){
          C_matrix[(i+1),1]<--C1[i]/alpha_0
          C_matrix[(i+1),(i+1)]<--growth/K
        }
        pars_1  <- list(
          C = C_matrix,
          r = c(-resp,rep(growth,numb_sr)),
          i = rep(inv,numb_sr+1)
        )
        C_matrix<-cbind(C_matrix,rep(0,numb_sr+1))
        C_matrix<-rbind(C_matrix,rep(0,numb_sr+2))
        
        C_matrix[numb_sr+2,] <- c(0,epsilon*C2/alpha_0,0)
        for (i in 1:numb_sr){
          C_matrix[(i+1),numb_sr+2] <- -C2[i]/alpha_0
        }
        
        pars_1  <- list(
          C = C_matrix,
          r = c(-resp,rep(growth,numb_sr),-resp),
          i = rep(inv,numb_sr+2)
        )
      }
      C2_old<-C2
      # Add num_comps # of competitors
      for (kk in 1:num_comps){
        
        agg_2<-sample(agg_all,1)
        numb_sr<-length(C1)
        Sr<-numb_sr
        
        repeat{
          # Ensure they do not activate serial extinction
          repeat{
            C2 <- sample_and_ser_ext(agg_2)
            if(Sr==length(C2)) break
          }
          HH_temp<-cbind(HH,matrix(C2,ncol=1))
          t_HH<-sum(C1*C2);t_HH_old<-sum(C2_old*C2)
          # Check if a) no species are outcompeted due to Phyrric, b) C1 not outcompeted due to exploitative
          # c) old original competitor no overexploited either
          if(sum(!outcompetition(HH_temp))==(kk+2) & ( ((sum(C1)-1)/t_HH) / ( (sum(C2)-1)/sum(C2^2) ) > 1) &
             ( ((sum(C2_old)-1)/t_HH_old) / ( (sum(C2)-1)/sum(C2^2) ) > 1)) break
          # break
        }
        
        # Construct interaction matrix #
        HH<-HH_temp
        C_matrix<-cbind(C_matrix,rep(0,dim(C_matrix)[1]))
        C_matrix<-rbind(C_matrix,rep(0,dim(C_matrix)[2]))
        insert<-c(0,C2/alpha_0,rep(0,kk),0)
        C_matrix[dim(C_matrix)[2],] <- insert*epsilon
        for (i in 1:dim(C_matrix)[2]){
          C_matrix[i,dim(C_matrix)[2]] <- -insert[i]
        }
      }
      
      pars_1  <- list(
        C = C_matrix,
        r = c(-resp,rep(growth,numb_sr),-resp,rep(-resp,num_comps)),
        i = rep(inv,numb_sr+2)
      )
      
      BRelaxed_1<-c("no","no")
      try({BRelaxed_1 <- -solve(C_matrix)%*%as.matrix(pars_1$r,col=1)},silent = T)
      if(is.numeric(BRelaxed_1[1])) break
      }
      
      # BRelaxed_1 <- -solve(C_matrix)%*%as.matrix(pars_1$r,col=1) # Calculate equilibrium biomasses
      amount_list_1_diff<-rbind(amount_list_1_diff,list(d1=(BRelaxed_1[1]<0))) #Check if C1 is still dead
  }
  
  # Fraction of times  C1 main resource goes extinct
  mean(unlist(amount_list_1_diff))
  
  write.csv(cbind(amount_list_1_diff,agg_all),file=paste(num_comps,"/Data/Raw/Validation/amount_list_1_diff.txt",sep=""))
}

#####################################
## Type II Exploitative competition #
#####################################
args = c(0.1,0.3,0.5,0.7,0.9)
for (ll in 1:length(args)){
  
   # Number of replicates per aggressiveness value
  amount_list_2_diff<-c()
  num_comps<-round(as.numeric(args[ll])*numb_comps_og)
  numb_sr<-numb_sr_og
  # Generate list of links that can overcome respiration per aggressiveness values:
  links_1<-llply(agg_all,function(x) sample_and_ser_ext(x))
  
  for (j in 1:length(agg_all)){

    cat(j/length(agg_all)*100,"%","\r")
    C1<-unlist(links_1[j])
    
    # Build interaction matrix with C1 (focal), C2 (first competitor) and resources
    repeat{
      # Sample C1 (focal) and C2 (first competitor)
      {
        repeat{
          numb_sr<-numb_sr_og 
          agg_1<-sample(agg_all,1) # Sample C1 (focal)
          C1 <- sample_and_ser_ext(agg_1) # Serial extinction of C1
          C1_temp<-C1
          C1_max<-which.max(C1_temp) # Idenitfy maximal link
          agg_2<-sample(agg_all,1) # Sample C2 (competitor)
          C2 <- sample_and_ser_ext(agg_2)  # Serial extinction of C2
          if(length(C2)<length(C1_temp)){ # Check that C1 and C2 have the same number of links, remove links until they do
            C1_temp<-C1_temp[-sample((1:length(C1_temp))[-C1_max],length(C1_temp)-length(C2))]
          } else if (length(C2)>length(C1_temp)){
            C2<-C2[-sample((1:length(C2))[-which.max(C2)],length(C2)-length(C1_temp))]
          }
          
          
          C1_max<-which.max(C1_temp) 
          t_HH<-sum(C1_temp*C2) 
          HH<-matrix(C1_temp,ncol=1);HH<-cbind(HH,matrix(C2,ncol=1)) # Create community matrix of C1, C2 and shared R's
          
          # Ensure that a) trophic links > 3, b) C1 and C2 do not share a common maximal resource, 
          # c) C1 is not outcompeted due to phyrric comp d) C1 is not outcompeted due to exploitative comp
          # e) both C1 and C2 can overcome respiration 
          # f) C2 does not need to commit serial extinction again
          if (length(C2)>=3 &
              which.max(C2) != C1_max & !any(outcompetition(HH)) &
              ( ((sum(C1_temp)-1)/t_HH) / ( (sum(C2)-1)/sum(C2^2) ) > 1) &
              sum(C1_temp)>1 & sum(C2)>1 &
              length(serial_extinction_t(C2))==length(C2) ){break}
          # if not repeat sampling of C1, C2 and shared resources
        }
        
        # Construct interaction matrix
        C1<-C1_temp
        numb_sr<-length(C1)
        C_matrix<-matrix(rep(0,(numb_sr+1)^2),ncol=numb_sr+1)
        C_matrix[1,]<-c(0,epsilon*C1/alpha_0)
        for (i in 1:numb_sr){
          C_matrix[(i+1),1]<--C1[i]/alpha_0
          C_matrix[(i+1),(i+1)]<--growth/K
        }
        pars_1  <- list(
          C = C_matrix,
          r = c(-resp,rep(growth,numb_sr)),
          i = rep(inv,numb_sr+1)
        )
        C_matrix<-cbind(C_matrix,rep(0,numb_sr+1))
        C_matrix<-rbind(C_matrix,rep(0,numb_sr+2))
        
        C_matrix[numb_sr+2,] <- c(0,epsilon*C2/alpha_0,0)
        for (i in 1:numb_sr){
          C_matrix[(i+1),numb_sr+2] <- -C2[i]/alpha_0
        }
        
        pars_1  <- list(
          C = C_matrix,
          r = c(-resp,rep(growth,numb_sr),-resp),
          i = rep(inv,numb_sr+2)
        )
    }
    
      C2_old<-C2
      # Add num_comps # of competitors
      for (kk in 1:num_comps){
      
      agg_2<-sample(agg_all,1)
      numb_sr<-length(C1)
      Sr<-numb_sr
      
      repeat{
        # Ensure they do not activate serial extinction
        repeat{
          C2 <- sample_and_ser_ext(agg_2)
          if(Sr==length(C2)) break
        }
        HH_temp<-cbind(HH,matrix(C2,ncol=1))
        t_HH<-sum(C1*C2);t_HH_old<-sum(C2_old*C2)
        # Check if a) no species are outcompeted due to Phyrric, b) C1 not outcompeted due to exploitative
        # c) old original competitor no overexploited either
        if(sum(!outcompetition(HH_temp))==(kk+2) & ( ((sum(C1)-1)/t_HH) / ( (sum(C2)-1)/sum(C2^2) ) > 1) &
           ( ((sum(C2_old)-1)/t_HH_old) / ( (sum(C2)-1)/sum(C2^2) ) > 1)) break
        # break
      }
      
      # Construct interaction matrix #
      HH<-HH_temp
      C_matrix<-cbind(C_matrix,rep(0,dim(C_matrix)[1]))
      C_matrix<-rbind(C_matrix,rep(0,dim(C_matrix)[2]))
      insert<-c(0,C2/alpha_0,rep(0,kk),0)
      C_matrix[dim(C_matrix)[2],] <- insert*epsilon
      for (i in 1:dim(C_matrix)[2]){
        C_matrix[i,dim(C_matrix)[2]] <- -insert[i]
      }
    }

      pars_1  <- list(
        C = C_matrix,
        r = c(-resp,rep(growth,numb_sr),-resp,rep(-resp,num_comps)),
        i = rep(inv,numb_sr+2)
      )

      BRelaxed_1<-c("no","no")
      try({BRelaxed_1 <- -solve(C_matrix)%*%as.matrix(pars_1$r,col=1)},silent = T)
      if(is.numeric(BRelaxed_1[1])) break
      }
    
      # BRelaxed_1 <- -solve(C_matrix)%*%as.matrix(pars_1$r,col=1) # Calculate equilibrium biomasses
      amount_list_2_diff<-rbind(amount_list_2_diff,list(d1=(BRelaxed_1[1]>0))) #Check if C1 is still alive
  }
  
  # Fraction of times  C1 main resource goes extinct
  mean( unlist(amount_list_2_diff) )
  write.csv(cbind(amount_list_2_diff,agg_all),file=paste(num_comps,"/Data/Raw/Validation/amount_list_2_diff.txt",sep=""))
}

alive_ws_dead<-(1-mean(unlist(amount_list_2_diff)))*length(agg_all)
correct_alive<-mean(unlist(amount_list_2_diff))*length(agg_all)
dead_ws_alive<-(1-mean(unlist(amount_list_1_diff)))*length(agg_all)
correct_dead<-mean(unlist(amount_list_1_diff))*length(agg_all)

dead_alive<-matrix(c(correct_alive, alive_ws_dead, dead_ws_alive, correct_dead),
       nrow = 2,
       dimnames = list(Guess = c("Alive", "Dead"),
                       Truth = c("Alive", "Dead")))
fisher.test(dead_alive, alternative = "greater")